name: ai-review
on: [pull_request]

jobs:
  specialist:
    name: ai/${{ matrix.role }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        role: [security, performance, elixir, typescript, ui, requirements]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ensure history for robust diffs/merge-base

      - name: Generate PR diff
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEADSHA="${{ github.event.pull_request.head.sha }}"
          else
            BASE=$(git rev-parse HEAD^)
            HEADSHA=$(git rev-parse HEAD)
          fi
          # Fetch the exact SHAs (works with forks and shallow clones)
          git fetch --no-tags --prune --depth=1 origin "+${BASE}" "+${HEADSHA}"
          # Produce a diff between the two trees (no merge-base required)
          git diff --unified=0 "${BASE}" "${HEADSHA}" > diff.patch
          # Ensure file exists (do not truncate if already written)
          [ -f diff.patch ] || touch diff.patch

      - name: Harden workspace (read-only)
        run: |
          set -euo pipefail
          mkdir -p ai
          chmod -R a-w .
          chmod u+w ai

      - name: Install Codex CLI
        run: npm i -g @openai/codex

      - name: Run Codex reviewer (diff-first, self-serve context)
        id: run
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_ORG_KEY: ${{ secrets.OPENAI_ORG_KEY }}
        run: |
          set -euo pipefail
          ROLE="${{ matrix.role }}"
          export ROLE

          {
            echo "You are a specialist reviewer for ${ROLE}.";
            echo "PRIMARY SOURCE: the DIFF below.";
            echo "If the DIFF is insufficient to judge correctness/safety, you MAY open files in the workspace to gather LIMITED context.";
            echo "ALLOWED PATHS: lib/**, assets/src/**, config/**, priv/repo/migrations/**";
            echo "DENYLIST: node_modules/**, deps/**, build/**, _build/**, .git/**";
            echo "Limits: at most 5 extra files total, and ≤1000 lines per file. Prefer narrow ranges near the changed lines.";
            echo "";
            echo "Return ONLY strict JSON matching .review/CONTRACT.json, extended with:";
            echo '  "context_used": [{"path":"","lines":"L10-L80"}]';
            echo "";
            echo "Rules:";
            echo "- Focus on changed lines; use extra context only when necessary.";
            echo "- Fail only for truly blocking issues; include file+line and a concrete fix.";
            echo "- Confidence = 0..1.";
            echo "";
            echo "---CHECKLIST START---";
            [ -f ".review/${ROLE}.md" ] && cat ".review/${ROLE}.md" || echo "(no checklist for ${ROLE})";
            echo "---CHECKLIST END---";
            echo "---DIFF START---";
            head -c 150000 diff.patch;
            echo "---DIFF END---";
          } > ai/prompt.${ROLE}.txt

          # Run Codex reviewer (non-streaming output). Some versions don't support --no-stream;
          # relying on default behavior with --stdin and --format json.
          # Feed prompt via STDIN (portable across Codex CLI versions)
          codex exec < ai/prompt.${ROLE}.txt > ai/${ROLE}.raw.txt

          # Extract the first JSON object from output robustly.
          node -e '
            const fs=require("fs");
            const role=process.env.ROLE;
            if(!role){ console.error("ROLE env missing"); process.exit(2); }
            const raw=fs.readFileSync(`ai/${role}.raw.txt`,`utf8`);
            const m=raw.match(/\{[\s\S]*?\}/);
            if(!m){ console.error("No JSON object found in output"); process.exit(2) }
            fs.writeFileSync(`ai/${role}.json`, m[0]);
          '

      - name: Validate JSON against contract
        run: |
          node -e '
            const fs=require("fs");
            const s=JSON.parse(fs.readFileSync("ai/${{ matrix.role }}.json","utf8"));
            if(!["pass","warn","fail"].includes(s.verdict)) process.exit(3);
          '

      - uses: actions/upload-artifact@v4
        with:
          name: ai-results
          path: ai/${{ matrix.role }}.json

      - name: Ensure no repo changes (tracked files only)
        run: |
          git status --porcelain --untracked-files=no
          test -z "$(git status --porcelain --untracked-files=no)" || (echo "Workspace mutated!"; git --no-pager diff; exit 1)

  aggregate:
    name: ai/review
    runs-on: ubuntu-latest
    needs: [specialist]
    steps:
      - uses: actions/download-artifact@v4
        with: { name: ai-results, path: ai }

      - name: Aggregate & decide
        id: agg
        run: |
          node -e '
            const fs=require("fs"), path=require("path");
            const files=fs.readdirSync("ai").filter(f=>f.endsWith(".json"));
            const results=files.map(f=>({role:f.replace(".json",""), ...JSON.parse(fs.readFileSync(path.join("ai",f),"utf8"))}));
            // Policy: fail if any fail with confidence >= 0.6 OR 2+ warns
            const fails=results.filter(r=>r.verdict==="fail" && r.confidence>=0.6);
            const warns=results.filter(r=>r.verdict==="warn");
            const status = (fails.length || warns.length>=2) ? "fail" : "pass";
            const md = [
              `### AI Review Summary`,
              `Status: **${status.toUpperCase()}**`,
              "",
              ...results.map(r=>`- **${r.role}**: ${r.verdict} (conf ${r.confidence}) — ${r.findings?.length||0} findings`)
            ].join("\n");
            fs.writeFileSync("ai/verdict.json", JSON.stringify({status, results, markdown: md}, null, 2));
          '

      - name: Post single summary comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const v = JSON.parse(fs.readFileSync('ai/verdict.json','utf8'));
            // one tidy summary comment
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: v.markdown
            });

      - name: Convert findings to annotations (optional)
        run: |
          node -e '
            const fs=require("fs"), v=JSON.parse(fs.readFileSync("ai/verdict.json","utf8"));
            for(const r of v.results){
              for(const f of (r.findings||[])){
                const lvl = f.severity==="high" ? "error" : (f.severity==="medium" ? "warning" : "notice");
                console.log(`::${lvl} file=${f.path},line=${f.line}::[${r.role}] ${f.title} — ${f.advice}`);
              }
            }
          '

      - name: Fail or pass the check
        run: |
          test "$(jq -r .status < ai/verdict.json)" = "pass" || exit 1
