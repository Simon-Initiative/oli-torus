{"version":3,"file":"pathOperations.js","sourceRoot":"","sources":["../../../src/utils/pathOperations.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,UAAU,CAAC;AAG1B,oEAAoE;AACpE,MAAM,UAAU,QAAQ,CAAC,IAAyB,EAAE,GAAoB;IACtE,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;AAC7C,CAAC;AAED,qEAAqE;AACrE,MAAM,UAAU,KAAK,CAAC,IAAyB,EAAE,EAAiB;IAChE,IAAI,EAAE,CAAC,IAAI,KAAK,eAAe,EAAE;QAC/B,uDAAuD;QACvD,OAAO,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;KAChF;IAED,OAAO,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,EAAE;QACxC,IAAI,EAAE,CAAC,IAAI,KAAK,iBAAiB,EAAE;YACjC,qEAAqE;YACrE,gBAAgB;YAChB,IAAI,EAAE,CAAC,KAAK,KAAK,SAAS,IAAI,EAAE,CAAC,KAAK,KAAK,CAAC,CAAC,EAAE;gBAC7C,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;aACtB;iBAAM;gBACL,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;aACrC;YACD,OAAO,MAAM,CAAC;SACf;QACD,IAAI,EAAE,CAAC,IAAI,KAAK,kBAAkB,EAAE;YAClC,mEAAmE;YACnE,qDAAqD;YACrD,OAAO,EAAE,CAAC,IAAI,CAAC;SAChB;QAED,IAAI,EAAE,CAAC,IAAI,KAAK,iBAAiB,EAAE;YACjC,oGAAoG;YACpG,OAAO,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,aAAa,CAAC,CAAC;SACnD;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AA8BD,MAAM,CAAC,MAAM,IAAI,GAAG,CAAC,IAAY,EAAiB,EAAE,CAAC,CAAC;IACpD,IAAI,EAAE,eAAe;IACrB,IAAI;CACL,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,IAAY,EAAE,IAAS,EAAE,KAAc,EAAmB,EAAE,CAAC,CAAC;IACnF,IAAI,EAAE,iBAAiB;IACvB,IAAI;IACJ,IAAI;IACJ,KAAK;CACN,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,OAAO,GAAG,CAAC,IAAY,EAAE,IAAS,EAAoB,EAAE,CAAC,CAAC;IACrE,IAAI,EAAE,kBAAkB;IACxB,IAAI;IACJ,IAAI;CACL,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,IAAY,EAAE,aAAqB,EAAmB,EAAE,CAAC,CAAC;IAC/E,IAAI,EAAE,iBAAiB;IACvB,IAAI;IACJ,aAAa;CACd,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,UAAU,GAAG;IACxB,IAAI;IACJ,MAAM;IACN,OAAO;IACP,MAAM;IACN,KAAK;IACL,QAAQ;CACT,CAAC","sourcesContent":["import jp from 'jsonpath';\nexport type PathOperation = FindOperation | InsertOperation | ReplaceOperation | FilterOperation;\n\n// apply a series of transformations which may mutate the given json\nexport function applyAll(json: Record<string, any>, ops: PathOperation[]): void {\n  ops.forEach((op) => op && apply(json, op));\n}\n\n// apply a single operation and return the possibly transformed value\nexport function apply(json: Record<string, any>, op: PathOperation): any[] {\n  if (op.type === 'FindOperation') {\n    // jsonpath returns a list of lists that match the path\n    return jp.query(json, op.path).reduce((acc, result) => acc.concat(result), []);\n  }\n\n  return jp.apply(json, op.path, (result) => {\n    if (op.type === 'InsertOperation') {\n      // Impl of 'InsertOperation' is to insert at a specific index an item\n      // into an array\n      if (op.index === undefined || op.index === -1) {\n        result.push(op.item);\n      } else {\n        result.splice(op.index, 0, op.item);\n      }\n      return result;\n    }\n    if (op.type === 'ReplaceOperation') {\n      // Impl of 'ReplaceOperation' is simply returning the value of item\n      // that will then replace the item matched via 'path'\n      return op.item;\n    }\n\n    if (op.type === 'FilterOperation') {\n      // This effectively replaces the results that match `op.path` with the results of `op.predicatePath`\n      return jp.query(json, op.path + op.predicatePath);\n    }\n  });\n}\n\n// Find an element in a list\nexport type FindOperation = {\n  type: 'FindOperation';\n  path: string;\n};\n\n// Insert into a list\nexport type InsertOperation = {\n  type: 'InsertOperation';\n  path: string;\n  index?: number;\n  item: any;\n};\n\n// Replace the contents\nexport type ReplaceOperation = {\n  type: 'ReplaceOperation';\n  path: string;\n  item: any;\n};\n\n// Filter the list at `path` using `predicatePath`\nexport type FilterOperation = {\n  type: 'FilterOperation';\n  path: string;\n  predicatePath: string;\n};\n\nexport const find = (path: string): FindOperation => ({\n  type: 'FindOperation',\n  path,\n});\n\nexport const insert = (path: string, item: any, index?: number): InsertOperation => ({\n  type: 'InsertOperation',\n  path,\n  item,\n  index,\n});\n\nexport const replace = (path: string, item: any): ReplaceOperation => ({\n  type: 'ReplaceOperation',\n  path,\n  item,\n});\n\nexport const filter = (path: string, predicatePath: string): FilterOperation => ({\n  type: 'FilterOperation',\n  path,\n  predicatePath,\n});\n\nexport const Operations = {\n  find,\n  insert,\n  replace,\n  filter,\n  apply,\n  applyAll,\n};\n"]}