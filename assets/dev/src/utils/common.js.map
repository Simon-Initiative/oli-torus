{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/utils/common.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AACH,MAAM,CAAC,MAAM,OAAO,GAAG,CAAI,KAA2B,EAAE,YAAe,EAAK,EAAE,CAC5E,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC;AAE/D,8EAA8E;AAC9E,MAAM,UAAU,WAAW,CAAC,CAAM;IAChC,MAAM,IAAI,KAAK,CAAC,qBAAqB,GAAG,CAAC,CAAC,CAAC;AAC7C,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,KAAK,CAAC,CAAM;IAC1B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC;AAED,uEAAuE;AACvE,MAAM,UAAU,WAAW,CAAC,KAAY;IACtC,OAAO,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AAClC,CAAC;AACD,+BAA+B;AAC/B,SAAS,UAAU,CAAC,IAAS;IAC3B,IAAI;QACF,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjB,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;gBAC5B,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC/B,MAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;oBACnC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;oBAC3B,IAAI,IAAI,KAAK,GAAG,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;wBACrD,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBAC9B,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE;4BACvC,OAAO,KAAK,CAAC;yBACd;qBACF;iBACF;aACF;SACF;QACD,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,IAAI,CAAC;KACb;AACH,CAAC;AAED,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAY,EAAW,EAAE,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC;AAE3E,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAoB,EAAW,EAAE,CACxD,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAEhD,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,KAAgC,EAAW,EAAE,CACxE,KAAK,KAAK,SAAS;IACnB,CAAC,KAAK,KAAK,IAAI;QACb,KAAK,KAAK,CAAC;QACX,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM;QACzC,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,IAAI;QACvC,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,GAAG,CAAC,CAAC;AAE5C,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,CAAU,EAAW,EAAE,CACnD,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC;AAEjF,8DAA8D;AAC9D,qDAAqD;AACrD,gCAAgC;AAChC,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,GAAY,EAAa,EAAE;IACpD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,IAAY,EAAE,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;KACxD;IAED,IAAI,aAAa,CAAC,GAAG,CAAC,EAAE;QACtB,IAAI;YACF,oEAAoE;YACpE,mDAAmD;YACnD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAa,CAAC,CAAC;YACvC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACvB,OAAO,IAAI,CAAC;aACb;SACF;QAAC,OAAO,GAAG,EAAE;YACZ,mDAAmD;SACpD;QACD,MAAM,KAAK,GAAI,GAAc,CAAC,SAAS,CAAC,CAAC,EAAG,GAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvE,MAAM,QAAQ,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,QAAQ,EAAE;YACZ,mDAAmD;YACnD,0CAA0C;YAC1C,uCAAuC;YACvC,uEAAuE;YACvE,MAAM,QAAQ,GAAG,KAAK;iBACnB,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC;iBAC3B,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC;iBAC1B,KAAK,CAAC,MAAM,CAAC,CAAC;YACjB,OAAO,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SACjC;aAAM;YACL,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAY,EAAE,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;YAC9E,MAAM,OAAO,GAAG,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;YAC5D,MAAM,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;YAC5C,IAAI,QAAQ,EAAE;gBACZ,OAAO,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;aACpC;YAED,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;gBACjC,IAAI,OAAO,OAAO,KAAK,QAAQ;oBAAE,OAAO,OAAO,CAAC;gBAChD,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;oBAC1B,OAAO,OAAO,CAAC;iBAChB;qBAAM;oBACL,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;iBACvB;YACH,CAAC,CAAC,CAAC;SACJ;KACF;IAED,IAAI,CAAC,GAAG,EAAE;QACR,OAAO,EAAE,CAAC;KACX;SAAM,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAClC,qMAAqM;QACrM,yGAAyG;QACzG,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAY,EAAE,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;KACnE;IACD,2CAA2C;IAC3C,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;IAC3C,+BAA+B;IAC/B,MAAM,GAAG,CAAC;AACZ,CAAC,CAAC;AAEF,0CAA0C;AAC1C,sDAAsD;AACtD,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,GAAQ,EAAE,EAAE;IACpC,uBAAuB;IACvB,MAAM,GAAG,GAAW,CAAC,GAAG,CAAC;IACzB,oDAAoD;IACpD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;AAChF,CAAC,CAAC;AAEF,iFAAiF;AACjF,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,IAAY,EAAmB,EAAE;IAC9D,MAAM,QAAQ,GAAG,OAAO,IAAI,CAAC;IAC7B,IAAI,CAAC,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,MAAM,CAAA;QAAE,OAAO,IAAI,CAAC;IAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;QAC/B,+DAA+D;QAC/D,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;KACzB;SAAM,IAAI,QAAQ,KAAK,QAAQ,EAAE;QAChC,8BAA8B;QAC9B,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;KACpB;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,4EAA4E;AAC5E,MAAM,CAAC,MAAM,GAAG,GAAG,CAAO,GAAQ,EAAE,GAAQ,EAAY,EAAE,CACxD,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAc,CAAC,CAAC","sourcesContent":["/**\n * Returns the given value if it is not null or undefined. Otherwise, it returns\n * the default value. The return value will always be a defined value of the type given\n * @param value\n * @param defaultValue\n */\nexport const valueOr = <T>(value: T | null | undefined, defaultValue: T): T =>\n  value === null || value === undefined ? defaultValue : value;\n\n// Allows completeness checking in discriminated union based switch statements\nexport function assertNever(x: any): never {\n  throw new Error('Unexpected object: ' + x);\n}\n\n/**\n * Performs a deep copy, or clone, of an object.\n *\n * @param o the object to clone\n * @returns the cloned object\n */\nexport function clone(o: any) {\n  return JSON.parse(JSON.stringify(o));\n}\n\n// Matches server implementation in `lib/oli/activities/parse_utils.ex`\nexport function removeEmpty(items: any[]) {\n  return items.filter(hasContent);\n}\n// Forgive me for I have sinned\nfunction hasContent(item: any) {\n  try {\n    if (item.content) {\n      const content = item.content;\n      if (content.model) {\n        const model = content.model;\n        if (model && model.length === 1) {\n          const children = model[0].children;\n          const type = model[0].type;\n          if (type === 'p' && children && children.length === 1) {\n            const text = children[0].text;\n            if (!text || !text.trim || !text.trim()) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n    return true;\n  } catch (e) {\n    return true;\n  }\n}\n\nexport const isString = (val: unknown): boolean => typeof val === 'string';\n\nexport const isNumber = (val: string | number): boolean =>\n  typeof val === 'number' && !Number.isNaN(val);\n\nexport const parseBoolean = (input: string | boolean | number): boolean =>\n  input !== undefined &&\n  (input === true ||\n    input === 1 ||\n    input.toString().toLowerCase() === 'true' ||\n    input.toString().toLowerCase() === 'on' ||\n    input.toString().toLowerCase() === '1');\n\nexport const isStringArray = (s: unknown): boolean =>\n  typeof s === 'string' && s.charAt(0) === '[' && s.charAt(s.length - 1) === ']';\n\n// this function is needed because of getting some values like\n// [some, thing, silly] vs [\"some\", \"thing\", \"silly\"]\n// otherwise we could just parse\nexport const parseArray = (val: unknown): unknown[] => {\n  if (Array.isArray(val)) {\n    return val.map((item: string) => parseNumString(item));\n  }\n\n  if (isStringArray(val)) {\n    try {\n      // its possible that we just get arrays of numbers which this should\n      // work fine for or even a normal stringified array\n      const json = JSON.parse(val as string);\n      if (Array.isArray(json)) {\n        return json;\n      }\n    } catch (err) {\n      // guess it wasn't valid, now we'll try to parse it\n    }\n    const inner = (val as string).substring(1, (val as string).length - 1);\n    const isNested = isStringArray(inner);\n    if (isNested) {\n      // NOTE this will only support ONE level of nesting\n      // otherwise the comma will break it again\n      // maybe there is some better regex way\n      // tagging them with newline just for something to target for the split\n      const innerEls = inner\n        .replace(/\\], \\[/g, '],\\n[')\n        .replace(/\\],\\[/g, '],\\n[')\n        .split(/,\\n/g);\n      return innerEls.map(parseArray);\n    } else {\n      const elements = inner.split(',').map((item: string) => parseNumString(item));\n      const isEmpty = elements.length === 1 && elements[0] === '';\n      const parsedArray = isEmpty ? [] : elements;\n      if (isNested) {\n        return parsedArray.map(parseArray);\n      }\n\n      return parsedArray.map((element) => {\n        if (typeof element !== 'string') return element;\n        if (element.match(/^\\s+$/)) {\n          return element;\n        } else {\n          return element.trim();\n        }\n      });\n    }\n  }\n\n  if (!val) {\n    return [];\n  } else if (typeof val === 'string') {\n    //if the val = 'abc' or val = '3,1,8' then it does not go in any of the above conditions and was throwing error. Since this fn will be used in contains operator as well, we need to return something\n    // because there could be a rules saying val.contains('abc'). it's not an array but it is valid condition\n    return val.split(',').map((item: string) => parseNumString(item));\n  }\n  // if we hit this, it was something WAY off\n  const err = new Error('not a valid array');\n  // console.error(err, { val });\n  throw err;\n};\n\n// parse value and return accurate boolean\n// returns boolean values for both numbers and strings\nexport const parseBool = (val: any) => {\n  // cast value to number\n  const num: number = +val;\n  // have to ignore the false searchValue in 'replace'\n  return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace('false', '');\n};\n\n/** returns a number if the string can be a number, else leaves it as a string */\nexport const parseNumString = (item: string): string | number => {\n  const itemType = typeof item;\n  if (!item?.length) return item;\n  if (!Number.isNaN(Number(item))) {\n    // check if items are strings or numbers and converts if number\n    return parseFloat(item);\n  } else if (itemType === 'string') {\n    //trim() only works on strings\n    return item.trim();\n  }\n  return item;\n};\n\n// Zips two arrays. E.g. zip([1,2,3], [4,5,6,7]) == [[1, 4], [2, 5], [3, 6]]\nexport const zip = <T, U>(xs1: T[], xs2: U[]): [T, U][] =>\n  xs1.reduce((acc, x, i) => (i > xs2.length - 1 ? acc : acc.concat([[x, xs2[i]]])), [] as [T, U][]);\n"]}