{"version":3,"file":"format.js","sourceRoot":"","sources":["../../../src/utils/format.ts"],"names":[],"mappings":"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","sourcesContent":["import { measureTextWidth } from 'utils/measure';\n\nexport const convert = {\n  // Converts a zero-based index to an alpha notation.\n  //\n  // Examples:\n  //   0 -> 'A'\n  //   1 -> 'B'\n  //   25 -> 'Z'\n  //   26 -> 'AA'\n  //   27 -> 'AB'\n  //\n  toAlphaNotation: (index: number): string => {\n    if (index === undefined || index === null || index < 0) {\n      return '';\n    }\n\n    let num = index;\n    let rem;\n\n    let result = '';\n\n    do {\n      rem = num % 26;\n      num = Math.floor(num / 26);\n\n      // A pure conversion to base 26 that didn't use 0-9 would\n      // have to treat A as the zero.  This leads to a problem where\n      // we cannot yield our 'AA' as a desired representation for the\n      // value 26, since that effectively is '00', instead this algorithm\n      // would produce 'BA' aka '10' in regular base 26.  We can correct\n      // this by simply adjusting the first, leftmost digit, when there are\n      // more than one digits, by one (turning that leading B into an A).\n      const adjustment = num === 0 && result.length !== 0 ? -1 : 0;\n      result = String.fromCharCode(rem + adjustment + 65) + result;\n    } while (num !== 0);\n\n    return result;\n  },\n\n  /**\n   * Returns the string representation of bytes converted to the correct units.\n   * Inspired by Bytes utility https://github.com/visionmedia/bytes.js\n   * @param value value to convert to string\n   * @param decimalPlaces number of decimal places to include in result\n   */\n  toByteNotation: (value: number, decimalPlaces = 2) => {\n    if (!Number.isFinite(value)) {\n      return null;\n    }\n\n    const UNIT_MAP = {\n      b: 1,\n      kb: 1 << 10,\n      mb: 1 << 20,\n      gb: 1 << 30,\n      tb: (1 << 30) * 1024,\n    } as any;\n\n    const mag = Math.abs(value);\n    let unit;\n\n    if (mag >= UNIT_MAP.tb) {\n      unit = 'TB';\n    } else if (mag >= UNIT_MAP.gb) {\n      unit = 'GB';\n    } else if (mag >= UNIT_MAP.mb) {\n      unit = 'MB';\n    } else if (mag >= UNIT_MAP.kb) {\n      unit = 'KB';\n    } else {\n      unit = 'B';\n    }\n\n    const val = value / UNIT_MAP[unit.toLowerCase()];\n    const str = val\n      .toFixed(decimalPlaces)\n      .replace(/^(.+)\\.?[0]+$/, '$1')\n      .replace(/\\.0$/, '');\n\n    return `${str} ${unit}`;\n  },\n\n  numberToWords: (num: number) => {\n    const ones = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\n    const tens = [\n      '',\n      '',\n      'twenty',\n      'thirty',\n      'forty',\n      'fifty',\n      'sixty',\n      'seventy',\n      'eighty',\n      'ninety',\n    ];\n    const teens = [\n      'ten',\n      'eleven',\n      'twelve',\n      'thirteen',\n      'fourteen',\n      'fifteen',\n      'sixteen',\n      'seventeen',\n      'eighteen',\n      'nineteen',\n    ];\n\n    const convertMillions = (num: number): string => {\n      if (num >= 1000000) {\n        return (\n          convertMillions(Math.floor(num / 1000000)) + ' million ' + convertThousands(num % 1000000)\n        );\n      }\n      return convertThousands(num);\n    };\n\n    const convertThousands = (num: number) => {\n      if (num >= 1000) {\n        return convertHundreds(Math.floor(num / 1000)) + ' thousand ' + convertHundreds(num % 1000);\n      }\n      return convertHundreds(num);\n    };\n\n    const convertHundreds = (num: number) => {\n      if (num > 99) {\n        return ones[Math.floor(num / 100)] + ' hundred ' + convertTens(num % 100);\n      }\n      return convertTens(num);\n    };\n\n    const convertTens = (num: number) => {\n      if (num < 10) return ones[num];\n      if (num >= 10 && num < 20) return teens[num - 10];\n      return tens[Math.floor(num / 10)] + ' ' + ones[num % 10];\n    };\n\n    if (num === 0) return 'zero';\n    return convertMillions(num);\n  },\n\n  /**\n   * Converts a decimal number to a percentage\n   */\n  toPercentage: (value: number) => Math.round(value * 100) + '%',\n};\n\nexport const stringFormat = {\n  /**\n   * Returns a truncated version of a string with elipsis\n   * @param text string to truncate\n   * @param maxLength max length of the truncated string\n   * @param postfixLength optional length of the end part of the truncated string to include\n   */\n  ellipsize: (text: string, maxLength: number, postfixLength = 0) => {\n    if (maxLength <= postfixLength + 3) {\n      throw Error('maxLength must be greater than postfixLength + 3');\n    }\n    if (text.length > maxLength) {\n      const front = text.substr(0, Math.min(maxLength, text.length) - 3 - postfixLength);\n\n      return `${front}...${text.substr(text.length - postfixLength, text.length)}`;\n    }\n\n    return text;\n  },\n\n  /**\n   * Returns a truncated version of a string with ellipsis.\n   * Maximum string length is 500 characters. Larger strings will be truncated\n   * to prevent the JavaScript event loop from locking up.\n   *\n   * WARNING: This might be an expensive call, as it renders the text into a canvas\n   * element to measure it\n   */\n  ellipsizePx: (\n    text: string,\n    maxWidth: number,\n    fontFamily: string,\n    fontSize: number,\n    fontWeight?: number,\n    fontStyle?: string,\n  ) => {\n    const MAX_TEXT_LENGTH = 500;\n    const ellipsizeWidth = measureTextWidth({\n      text: '...',\n      fontFamily,\n      fontSize,\n      fontWeight,\n      fontStyle,\n    });\n    const textWidth = measureTextWidth({\n      text,\n      fontFamily,\n      fontSize,\n      fontWeight,\n      fontStyle,\n    });\n\n    if (textWidth <= maxWidth) {\n      return text;\n    }\n\n    if (maxWidth <= ellipsizeWidth) {\n      console.error(\"ellipsizePx: maxWidth must be greater than size of ellipsis '...'\");\n      return '...';\n    }\n\n    const findLargestString = (str: string): string => {\n      return measureTextWidth({\n        text: `${str}...`,\n        fontFamily,\n        fontSize,\n        fontWeight,\n        fontStyle,\n      }) <= maxWidth\n        ? str\n        : findLargestString(str.substr(0, str.length - 1));\n    };\n\n    return findLargestString(text.substr(0, MAX_TEXT_LENGTH)) + '...';\n  },\n};\n"]}