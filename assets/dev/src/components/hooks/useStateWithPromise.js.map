{"version":3,"file":"useStateWithPromise.js","sourceRoot":"","sources":["../../../../src/components/hooks/useStateWithPromise.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAEjE,MAAM,mBAAmB,GAAG,CAAC,YAAiB,EAAc,EAAE;IAC5D,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;IACjD,MAAM,WAAW,GAAG,MAAM,CAAM,IAAI,CAAC,CAAC;IAEtC,SAAS,CAAC,GAAG,EAAE;QACb,IAAI,WAAW,CAAC,OAAO,KAAK,IAAI,EAAE;YAChC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC3B,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC;SAC5B;QACD;;;;;WAKG;IACL,CAAC,EAAE,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;IAEjC,MAAM,cAAc,GAAG,WAAW,CAChC,CAAC,WAAW,EAAE,EAAE;QACd,QAAQ,CAAC,WAAW,CAAC,CAAC;QACtB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC7B,WAAW,CAAC,OAAO,GAAG,OAAO,CAAC;QAChC,CAAC,CAAC,CAAC;IACL,CAAC,EACD,CAAC,QAAQ,CAAC,CACX,CAAC;IAEF,OAAO,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;AACjC,CAAC,CAAC;AAEF,eAAe,mBAAmB,CAAC","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\n\nconst useStateWithPromise = (initialState: any): [any, any] => {\n  const [state, setState] = useState(initialState);\n  const resolverRef = useRef<any>(null);\n\n  useEffect(() => {\n    if (resolverRef.current !== null) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\n     * Since a state update could be triggered with the exact same state again,\n     * it's not enough to specify state as the only dependency of this useEffect.\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\n     * that handleSetState was called in previous render\n     */\n  }, [resolverRef.current, state]);\n\n  const handleSetState = useCallback(\n    (stateAction) => {\n      setState(stateAction);\n      return new Promise((resolve) => {\n        resolverRef.current = resolve;\n      });\n    },\n    [setState],\n  );\n\n  return [state, handleSetState];\n};\n\nexport default useStateWithPromise;\n"]}