{"version":3,"file":"utils.jsx","sourceRoot":"","sources":["../../../../src/components/editing/utils.tsx"],"names":[],"mappings":"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","sourcesContent":["import { RichText } from 'components/activities/types';\nimport { ModelElement } from 'data/content/model/elements/types';\nimport { schema } from 'data/content/model/schema';\nimport { Mark, Marks } from 'data/content/model/text';\nimport {\n  Descendant,\n  Editor,\n  Element,\n  InsertNodeOperation,\n  Node,\n  NodeEntry,\n  Operation,\n  RemoveNodeOperation,\n  Text,\n} from 'slate';\nimport { Maybe } from 'tsmonad';\n\n// Native input selection -- not slate\nexport const cursorAtEndOfInput = (input: HTMLInputElement) => {\n  return input.selectionStart === input.selectionEnd && input.selectionStart === input.value.length;\n};\nexport const cursorAtBeginningOfInput = (input: HTMLInputElement) => {\n  return input.selectionStart === input.selectionEnd && input.selectionStart === 0;\n};\n\n// Returns true if a text node contains the mark string key\nexport function hasMark(textNode: Text, mark: string): boolean {\n  return Object.keys(textNode).some((k) => k === mark);\n}\n\nexport function elementsOfType<T extends Element>(root: Editor, type: string): T[] {\n  return [...Node.elements(root)]\n    .map(([element]) => element)\n    .filter((elem) => Element.isElement(elem) && elem.type === type) as T[];\n}\n\nexport function elementsAdded<T extends Element>(operations: Operation[], type: string): T[] {\n  return operations\n    .filter(\n      (operation) =>\n        operation.type === 'insert_node' &&\n        Element.isElement(operation.node) &&\n        operation.node.type === type,\n    )\n    .map((operation: InsertNodeOperation) => operation.node as T);\n}\n\nexport function elementsRemoved<T extends Element>(operations: Operation[], type: string): T[] {\n  return operations\n    .filter(\n      (operation) =>\n        operation.type === 'remove_node' &&\n        Element.isElement(operation.node) &&\n        operation.node.type === type,\n    )\n    .map((operation: RemoveNodeOperation) => operation.node as T);\n}\n\n// Returns all the Text nodes in the current selection\nexport function textNodesInSelection(editor: Editor) {\n  const selection = editor.selection;\n  if (!selection) {\n    return [];\n  }\n\n  return Node.fragment(editor, selection)\n    .map((node) =>\n      Array.from(Node.descendants(node)).reduce((acc: Text[], [node]) => {\n        return Text.isText(node) ? acc.concat(node) : acc;\n      }, []),\n    )\n    .reduce((acc, curr) => acc.concat(curr), []);\n}\n\nexport function isMarkActive(editor: Editor, mark: Mark): boolean {\n  return marksInPartOfSelection(editor).includes(mark);\n}\n\n// Returns a Mark[] that apply to the entire current selection\nexport function marksInEntireSelection(editor: Editor) {\n  const marks: any = {};\n  const textNodes = textNodesInSelection(editor);\n  textNodes.forEach((text) => {\n    Object.keys(text)\n      .filter((k) => k in Marks)\n      .forEach((mark) => (marks[mark] ? (marks[mark] += 1) : (marks[mark] = 1)));\n  });\n  return Object.entries(marks)\n    .filter(([, v]) => v === textNodes.length)\n    .map(([k]) => k as Mark);\n}\n\n// Returns a Mark[] of all marks that exist in any part of the current selection\nexport function marksInPartOfSelection(editor: Editor) {\n  const marks: any = {};\n  textNodesInSelection(editor).forEach((text) => {\n    Object.keys(text)\n      .filter((k) => k in Marks)\n      .forEach((mark) => (marks[mark] = true));\n  });\n  return Object.keys(marks);\n}\n\n// Extracts the text from a hierarchy of nodes\nexport function toSimpleText(nodes: RichText | Descendant[]): string;\nexport function toSimpleText(node: Node): string;\nexport function toSimpleText(node: Node | RichText | Descendant[]): string {\n  if (Array.isArray(node)) return toSimpleTextHelper({ children: node } as ModelElement, '');\n  return toSimpleTextHelper(node, '');\n}\n\nfunction toSimpleTextHelper(node: Node, text: string): string {\n  if (Text.isText(node)) return text + node.text;\n  return [...node.children].reduce((p, c) => {\n    if (Text.isText(c)) return p + c.text;\n    return toSimpleTextHelper(c, p);\n  }, text);\n}\n\nexport const isTopLevel = (editor: Editor) => {\n  const [...nodes] = Editor.nodes(editor, {\n    match: (n) => {\n      if (!Element.isElement(n)) return false;\n      const attrs = schema[n.type];\n      return attrs && attrs.isTopLevel;\n    },\n  });\n  return nodes.every((node) => node[1].length === 1);\n};\n\nexport const getHighestTopLevel = (editor: Editor): Maybe<Node> => {\n  if (!editor.selection) {\n    return Maybe.nothing();\n  }\n  let [node, path] = Editor.node(editor, editor.selection);\n\n  // eslint-disable-next-line\n  while (true) {\n    // TopLevel node is selected, only Editor node as parent\n    if (path.length === 1) {\n      return Maybe.maybe(node);\n    }\n    // Editor is selected\n    if (path.length === 0) {\n      return Maybe.nothing();\n    }\n    const [nextNode, nextPath] = Editor.parent(editor, path);\n    path = nextPath;\n    node = nextNode;\n  }\n};\n\n// For the current selection, walk up through the data model to find the\n// immediate block parent.\nexport const getNearestBlock = (editor: Editor): Maybe<ModelElement> => {\n  const block: NodeEntry<ModelElement> | undefined = Editor.above(editor, {\n    match: (n) => Editor.isBlock(editor, n),\n  });\n  if (block) {\n    return Maybe.just(block[0]);\n  }\n  return Maybe.nothing();\n};\n\nexport const isActive = (editor: Editor, type: string | string[]) => {\n  const [match] = Editor.nodes(editor, {\n    match: (n) =>\n      Element.isElement(n) &&\n      (typeof type === 'string' ? n.type === type : type.indexOf(n.type as string) > -1),\n  });\n  return !!match;\n};\n\nexport const isActiveList = (editor: Editor) => {\n  return isActive(editor, ['ul', 'ol']);\n};\n"]}