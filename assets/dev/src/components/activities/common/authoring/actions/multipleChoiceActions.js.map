{"version":3,"file":"multipleChoiceActions.js","sourceRoot":"","sources":["../../../../../../../src/components/activities/common/authoring/actions/multipleChoiceActions.ts"],"names":[],"mappings":"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","sourcesContent":["import { ResponseActions } from 'components/activities/common/responses/responseActions';\nimport { DEFAULT_PART_ID } from 'components/activities/common/utils';\nimport {\n  ChoiceId,\n  ChoiceIdsToResponseId,\n  HasParts,\n  makeResponse,\n  makeUndoable,\n  PostUndoable,\n  ResponseId,\n} from 'components/activities/types';\nimport { Choices } from 'data/activities/model/choices';\nimport { getCorrectResponse, getResponseBy, getResponseId } from 'data/activities/model/responses';\nimport { matchRule } from 'data/activities/model/rules';\nimport { clone } from 'utils/common';\nimport { Operations } from 'utils/pathOperations';\n\nexport const MCActions = {\n  removeChoice(id: string, partId = DEFAULT_PART_ID) {\n    return (model: any & HasParts, post: PostUndoable) => {\n      const choice = Choices.getOne(model, id);\n      const index = Choices.getAll(model).findIndex((c) => c.id === id);\n      Choices.removeOne(id)(model);\n\n      // if the choice being removed is the correct choice, a new correct choice\n      // must be set\n      const authoringClone = clone(model.authoring);\n      if (getCorrectResponse(model, partId).rule === matchRule(id)) {\n        const firstChoice = Choices.getAll(model)[0];\n        MCActions.toggleChoiceCorrectness(firstChoice.id, partId)(model, post);\n      }\n\n      const undoable = makeUndoable('Removed a choice', [\n        Operations.replace('$.authoring', authoringClone),\n        Operations.insert(Choices.path, clone(choice), index),\n      ]);\n      post(undoable);\n    };\n  },\n\n  toggleChoiceCorrectness(id: string, partId = DEFAULT_PART_ID) {\n    return (model: HasParts, _post: PostUndoable) => {\n      getCorrectResponse(model, partId).rule = matchRule(id);\n    };\n  },\n\n  editTargetedFeedbackChoice(responseId: ResponseId, choiceId: ChoiceId) {\n    return (\n      model: HasParts & { authoring: { targeted: ChoiceIdsToResponseId[] } },\n      _post: PostUndoable,\n    ) => {\n      const assoc = model.authoring.targeted.find(\n        (assoc: any) => getResponseId(assoc) === responseId,\n      );\n      if (!assoc) return;\n      assoc[0] = [choiceId];\n      getResponseBy(model, (r) => r.id === getResponseId(assoc)).rule = matchRule(choiceId);\n    };\n  },\n\n  addTargetedFeedback(partId = DEFAULT_PART_ID, choiceId?: string) {\n    return (model: HasParts & { authoring: { targeted: ChoiceIdsToResponseId[] } }) => {\n      const firstChoice = Choices.getAll(model)[0];\n      const response = makeResponse(matchRule(choiceId || firstChoice.id), 0, '');\n\n      // Insert new targeted response before the last response, which is the\n      // catch-all incorrect response. Response rules are evaluated in-order,\n      // so the catch-all should be the last response.\n      ResponseActions.addResponse(response, partId)(model);\n      model.authoring.targeted.push([[choiceId || firstChoice.id], response.id]);\n    };\n  },\n};\n"]}