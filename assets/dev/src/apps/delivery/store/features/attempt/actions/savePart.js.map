{"version":3,"file":"savePart.js","sourceRoot":"","sources":["../../../../../../../../src/apps/delivery/store/features/attempt/actions/savePart.ts"],"names":[],"mappings":"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","sourcesContent":["import { createAsyncThunk } from '@reduxjs/toolkit';\nimport { writePartAttemptState } from 'data/persistence/state/intrinsic';\nimport {\n  defaultGlobalEnv,\n  evalScript,\n  getAssignStatements,\n} from '../../../../../../adaptivity/scripting';\nimport { RootState } from '../../../rootReducer';\nimport { selectPreviewMode, selectSectionSlug } from '../../page/slice';\nimport {\n  AttemptSlice,\n  selectActivityAttemptState,\n  selectById,\n  upsertActivityAttemptState,\n} from '../slice';\n\nexport const savePartState = createAsyncThunk(\n  `${AttemptSlice}/savePartState`,\n  async (payload: any, { dispatch, getState }) => {\n    const { attemptGuid, partAttemptGuid, response } = payload;\n    const rootState = getState() as RootState;\n    const isPreviewMode = selectPreviewMode(rootState);\n    const sectionSlug = selectSectionSlug(rootState);\n\n    // update redux state to match optimistically\n    const attemptRecord = selectById(rootState, attemptGuid);\n    if (attemptRecord) {\n      const partAttemptRecord = attemptRecord.parts.find((p) => p.attemptGuid === partAttemptGuid);\n      if (partAttemptRecord) {\n        const updated = {\n          ...attemptRecord,\n          parts: attemptRecord.parts.map((p) => {\n            const result = { ...p };\n            if (p.attemptGuid === partAttemptRecord.attemptGuid) {\n              result.response = response;\n            }\n            return result;\n          }),\n        };\n        await dispatch(upsertActivityAttemptState({ attempt: updated }));\n      }\n    }\n\n    // update scripting env with latest values\n    const assignScripts = getAssignStatements(response);\n    const scriptResult: string[] = [];\n    if (Array.isArray(assignScripts)) {\n      //Need to execute scripts one-by-one so that error free expression are evaluated and only the expression with error fails. It should not have any impacts\n      assignScripts.forEach((variable: string) => {\n        // update scripting env with latest values\n        const { result } = evalScript(variable, defaultGlobalEnv);\n        //Usually, the result is always null if expression is executes successfully. If there are any errors only then the result contains the error message\n        if (result) scriptResult.push(result);\n      });\n    }\n    /*  console.log('SAVE PART SCRIPT', { assignScript, scriptResult }); */\n\n    // in preview mode we don't write to server, so we're done\n    if (isPreviewMode) {\n      // TODO: normalize response between client and server (nothing currently cares about it)\n      return { result: scriptResult };\n    }\n\n    const finalize = false;\n\n    return writePartAttemptState(sectionSlug, attemptGuid, partAttemptGuid, response, finalize);\n  },\n);\n\nexport const savePartStateToTree = createAsyncThunk(\n  `${AttemptSlice}/savePartStateToTree`,\n  async (payload: any, { dispatch, getState }) => {\n    const { attemptGuid, partAttemptGuid, response, activityTree } = payload;\n    const rootState = getState() as RootState;\n\n    const attemptRecord = selectById(rootState, attemptGuid);\n    const partId = attemptRecord?.parts.find((p) => p.attemptGuid === partAttemptGuid)?.partId;\n    if (!partId) {\n      throw new Error('cannot find the partId to update');\n    }\n\n    const updates = activityTree.map((activity: any) => {\n      const attempt = selectActivityAttemptState(rootState, activity.resourceId);\n      if (!attempt) {\n        return Promise.reject('could not find attempt!');\n      }\n      const attemptGuid = attempt.attemptGuid;\n      const partAttemptGuid = attempt.parts.find((p) => p.partId === partId)?.attemptGuid;\n      if (!partAttemptGuid) {\n        // means its in the tree, but doesn't own or inherit this part (some grandparent likely)\n        return Promise.resolve('does not own part but thats OK');\n      }\n      /* console.log('updating activity tree part: ', {\n        attemptGuid,\n        partAttemptGuid,\n        activity,\n        response,\n      }); */\n      return dispatch(savePartState({ attemptGuid, partAttemptGuid, response }));\n    });\n    return Promise.all(updates);\n  },\n);\n"]}