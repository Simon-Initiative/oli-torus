{"version":3,"file":"TextParser.js","sourceRoot":"","sources":["../../../../../src/apps/delivery/components/TextParser.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,6BAA6B,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AAElG,+DAA+D;AAE/D,MAAM,CAAC,MAAM,cAAc,GAAG,CAC5B,IAAY,EACZ,KAAU,EACV,GAAiB,EACjB,gBAAgB,GAAG,KAAK,EAChB,EAAE;IACV,IAAI,QAAQ,GAAG,GAAG,CAAC;IACnB,MAAM,IAAI,GAAG,6BAA6B,CAAC,IAAI,CAAC,CAAC;IACjD,uEAAuE;IACvE,IAAI,CAAC,IAAI,EAAE;QACT,OAAO,IAAI,CAAC;KACb;IACD,IAAI,gBAAgB,EAAE;QACpB,qFAAqF;QACrF,MAAM,mBAAmB,GAAG,IAAI,CAAC,KAAK,CACpC,+KAA+K,CAChL,CAAC;QACF,0HAA0H;QAC1H,IAAI,mBAAmB,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;KACF;IACD,qDAAqD;IACrD,IAAI;QACF,MAAM,iBAAiB,GAAG,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC3D,UAAU,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;KACzC;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CAAC,yCAAyC,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC;KACjF;IACD,4DAA4D;IAC5D,IAAI,eAAe,GAAG,IAAI,CAAC;IAE3B,yDAAyD;IACzD,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;;QAC1B,IAAI,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAI,CAAC,UAAU,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YACjD,IAAI;gBACF,IAAI,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;oBACzB,+DAA+D;oBAC/D,uEAAuE;oBACvE,uEAAuE;oBACvE,yEAAyE;oBACzE,sBAAsB;oBACtB,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC;iBACd;gBACD,MAAM,MAAM,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;gBACvC,wDAAwD;gBACxD,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC;gBACtB,IAAI,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,KAAI,CAAC,CAAA,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,0CAAE,OAAO,CAAA,EAAE;oBAC9C,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC;iBAC5B;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,UAAU;gBACV,OAAO,CAAC,GAAG,CAAC,uBAAuB,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;aAChD;SACF;QACD,IAAI,UAAU,KAAK,SAAS,EAAE;YAC5B,IAAI,gBAAgB,EAAE;gBACpB,OAAO,IAAI,CAAC;aACb;iBAAM;gBACL,OAAO,EAAE,CAAC;aACX;SACF;QACD,IAAI,QAAQ,GAAG,UAAU,CAAC;QAC1B,2DAA2D;QAE3D,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YAC7B,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACvD;aAAM,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YACzC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;SACvC;aAAM,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YACzC,QAAQ,GAAG,UAAU,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SACxD;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QACxB,eAAe,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IACxE,CAAC,CAAC,CAAC;IAEH,+CAA+C;IAC/C,OAAO,eAAe,CAAC,CAAC,oDAAoD;AAC9E,CAAC,CAAC","sourcesContent":["import { evalScript, extractAllExpressionsFromText, getAssignScript } from 'adaptivity/scripting';\nimport { Environment } from 'janus-script';\n// function to select the content between only the outermost {}\n\nexport const templatizeText = (\n  text: string,\n  state: any,\n  env?: Environment,\n  isFromTrapStates = false,\n): string => {\n  let innerEnv = env;\n  const vars = extractAllExpressionsFromText(text);\n  /* console.log('templatizeText call: ', { text, vars, state, env }); */\n  if (!vars) {\n    return text;\n  }\n  if (isFromTrapStates) {\n    //trying to check if it is a CSS string.This might not handle any advance CSS string.\n    const matchingCssElements = text.match(\n      /^(([a-z0-9\\\\[\\]=:]+\\s?)|((div|span|body.*|.button:hover.*|.button.*|.box-sizing:*|.columns-container.*|background-color.*)?(#|\\.){1}[a-z0-9\\-_\\s?:]+\\s?)+)(\\{[\\s\\S][^}]*})$/im,\n    );\n    //matchingCssElements !== null then it means it's a CSS string so set actuallyAString=true so that it can be wrapped in \"\"\n    if (matchingCssElements) {\n      return text;\n    }\n  }\n  /* innerEnv = evalScript(janus_std, innerEnv).env; */\n  try {\n    const stateAssignScript = getAssignScript(state, innerEnv);\n    evalScript(stateAssignScript, innerEnv);\n  } catch (e) {\n    console.warn('[Markup] error injecting state into env', { e, state, innerEnv });\n  }\n  /*  console.log('templatizeText', { text, state, vars }); */\n  let templatizedText = text;\n\n  // check for state items that were included in the string\n  const vals = vars.map((v) => {\n    let stateValue = state[v];\n    if (!stateValue || typeof stateValue === 'object') {\n      try {\n        if (v.indexOf(':') !== -1) {\n          // if the expression is just a variable, then if it has a colon\n          // it is most likely targetting another screen, and needs to be wrapped\n          // for evaluation; same with if it has a space in it TODO: detect that;\n          // also note this will break hash expression support but no one uses that\n          // currently (TODO #2)\n          v = `{${v}}`;\n        }\n        const result = evalScript(v, innerEnv);\n        /* console.log('trying to eval text', { v, result }); */\n        innerEnv = result.env;\n        if (result?.result && !result?.result?.message) {\n          stateValue = result.result;\n        }\n      } catch (e) {\n        // ignore?\n        console.log('error evaluating text', { v, e });\n      }\n    }\n    if (stateValue === undefined) {\n      if (isFromTrapStates) {\n        return text;\n      } else {\n        return '';\n      }\n    }\n    let strValue = stateValue;\n    /* console.log({ strValue, typeOD: typeof stateValue }); */\n\n    if (Array.isArray(stateValue)) {\n      strValue = stateValue.map((v) => `\"${v}\"`).join(', ');\n    } else if (typeof stateValue === 'object') {\n      strValue = JSON.stringify(stateValue);\n    } else if (typeof stateValue === 'number') {\n      strValue = parseFloat(parseFloat(strValue).toFixed(4));\n    }\n    return strValue;\n  });\n\n  vars.forEach((v, index) => {\n    templatizedText = templatizedText.replace(`{${v}}`, `${vals[index]}`);\n  });\n\n  // support nested {} like {{variables.foo} * 3}\n  return templatizedText; // templatizeText(templatizedText, state, innerEnv);\n};\n"]}