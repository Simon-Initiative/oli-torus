{"version":3,"file":"AdaptiveItemOptions.js","sourceRoot":"","sources":["../../../../../../src/apps/authoring/components/AdaptivityEditor/AdaptiveItemOptions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,WAAW,EAAE,MAAM,6BAA6B,CAAC;AAO7E,MAAM,CAAC,MAAM,WAAW,GAAiB;IACvC,EAAE,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,iBAAiB,CAAC,MAAM,EAAE;IAClE,EAAE,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,iBAAiB,CAAC,MAAM,EAAE;IAClE,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,iBAAiB,CAAC,KAAK,EAAE;IAC/D,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,iBAAiB,CAAC,OAAO,EAAE;IACrE,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,iBAAiB,CAAC,IAAI,EAAE;IAC5D,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,iBAAiB,EAAE,KAAK,EAAE,iBAAiB,CAAC,SAAS,EAAE;IAC5E,EAAE,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,iBAAiB,CAAC,WAAW,EAAE;CAC7E,CAAC;AAOF,MAAM,CAAC,MAAM,qBAAqB,GAA2B;IAC3D,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;IACvC,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE;IAC/C,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE;IAClD,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,YAAY,EAAE;CACxD,CAAC;AAOF,MAAM,CAAC,MAAM,wBAAwB,GAA8B;IACjE,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE;IAC3C,EAAE,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE;IAClD,EAAE,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,UAAU,EAAE;IACjD,EAAE,GAAG,EAAE,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,mBAAmB,EAAE;IACpE,EAAE,GAAG,EAAE,aAAa,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,aAAa,EAAE;IACvD,EAAE,GAAG,EAAE,sBAAsB,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,sBAAsB,EAAE;IAC1E,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;IACtC,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE;IAChD,EAAE,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,UAAU,EAAE;IACxD,EAAE,GAAG,EAAE,aAAa,EAAE,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,aAAa,EAAE;IAClE,EAAE,GAAG,EAAE,eAAe,EAAE,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,eAAe,EAAE;IACtE;QACE,GAAG,EAAE,kBAAkB;QACvB,IAAI,EAAE,kBAAkB;QACxB,KAAK,EAAE,kBAAkB;KAC1B;IACD,EAAE,GAAG,EAAE,cAAc,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,cAAc,EAAE;IACrE,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE;IACvD,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,YAAY,EAAE;IAC9D,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE;IAChD,EAAE,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,oBAAoB,EAAE;IACvE;QACE,GAAG,EAAE,uBAAuB;QAC5B,IAAI,EAAE,KAAK;QACX,KAAK,EAAE,uBAAuB;KAC/B;IACD,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAE;IACtD,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,YAAY,EAAE;IAChE;QACE,GAAG,EAAE,iBAAiB;QACtB,IAAI,EAAE,kBAAkB;QACxB,KAAK,EAAE,iBAAiB;KACzB;IACD;QACE,GAAG,EAAE,oBAAoB;QACzB,IAAI,EAAE,sBAAsB;QAC5B,KAAK,EAAE,oBAAoB;KAC5B;IACD,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,YAAY,EAAE;IAC/D,EAAE,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE;IACzD,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;IACtC,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE;IAChD,EAAE,GAAG,EAAE,cAAc,EAAE,IAAI,EAAE,gBAAgB,EAAE,KAAK,EAAE,cAAc,EAAE;IACtE,EAAE,GAAG,EAAE,mBAAmB,EAAE,IAAI,EAAE,qBAAqB,EAAE,KAAK,EAAE,mBAAmB,EAAE;IACrF,EAAE,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,gBAAgB,EAAE;IACzE,EAAE,GAAG,EAAE,mBAAmB,EAAE,IAAI,EAAE,mBAAmB,EAAE,KAAK,EAAE,mBAAmB,EAAE;IACnF,EAAE,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,WAAW,EAAE;IAC5D,EAAE,GAAG,EAAE,cAAc,EAAE,IAAI,EAAE,gBAAgB,EAAE,KAAK,EAAE,cAAc,EAAE;CACvE,CAAC;AAMF,MAAM,CAAC,MAAM,2BAA2B,GAAiC;IACvE,EAAE,IAAI,EAAE,iBAAiB,CAAC,OAAO,EAAE,SAAS,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE;IAC/D;QACE,IAAI,EAAE,iBAAiB,CAAC,IAAI;QAC5B,SAAS,EAAE;YACT,OAAO;YACP,UAAU;YACV,IAAI;YACJ,OAAO;YACP,yGAAyG;YACzG;;;;;4BAKgB;SACjB;KACF;IACD;QACE,IAAI,EAAE,iBAAiB,CAAC,MAAM;QAC9B,SAAS,EAAE;YACT,OAAO;YACP,UAAU;YACV,OAAO;YACP,IAAI;YACJ,SAAS;YACT,OAAO;YACP,aAAa;YACb,UAAU;YACV,sBAAsB;YACtB,mBAAmB;YACnB,oBAAoB;YACpB,uBAAuB;YACvB,SAAS;YACT,YAAY;SACb;KACF;IACD;QACE,IAAI,EAAE,iBAAiB,CAAC,MAAM;QAC9B,SAAS,EAAE;YACT,OAAO;YACP,UAAU;YACV,IAAI;YACJ,OAAO;YACP,WAAW;YACX,cAAc;YACd,UAAU;YACV,aAAa;YACb,iBAAiB;YACjB,oBAAoB;YACpB,eAAe;YACf,kBAAkB;YAClB,YAAY;YACZ,UAAU;SACX;KACF;IACD;QACE,IAAI,EAAE,iBAAiB,CAAC,KAAK;QAC7B,SAAS,EAAE;YACT,OAAO;YACP,UAAU;YACV,IAAI;YACJ,OAAO;YACP,UAAU;YACV,aAAa;YACb,eAAe;YACf,kBAAkB;YAClB,cAAc;SACf;KACF;IACD;QACE,IAAI,EAAE,iBAAiB,CAAC,SAAS;QACjC,SAAS,EAAE;YACT,WAAW;YACX,cAAc;YACd,gBAAgB;YAChB,mBAAmB;YACnB,cAAc;YACd,mBAAmB;SACpB;KACF;IACD;QACE,IAAI,EAAE,iBAAiB,CAAC,WAAW;QACnC,SAAS,EAAE,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,aAAa,CAAC;KAC3E;CACF,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAA4B;IACvD,aAAa,EAAE,CAAC;IAChB,oBAAoB,EAAE,CAAC;IACvB,MAAM,EAAE,KAAK;IACb,oBAAoB,EAAE,KAAK;IAC3B,cAAc,EAAE,CAAC;IACjB,iBAAiB,EAAE,CAAC;IACpB,aAAa,EAAE,CAAC;IAChB,MAAM,EAAE,EAAE;CACX,CAAC;AAEF,MAAM,CAAC,MAAM,6BAA6B,GAAG,CAAC,QAAgB,EAAE,KAAU,EAAqB,EAAE;IAC/F,MAAM,UAAU,GAAG,2BAA2B,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAC9D,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CACnC,CAAC;IACF,kGAAkG;IAClG,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;KAC3B;SAAM;QACL,2GAA2G;QAC3G,MAAM,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;QACrC,6DAA6D;QAC7D,qEAAqE;QACrE,MAAM,cAAc,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7D,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YACvC,uEAAuE;YACvE,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;SAC3B;QACD,uEAAuE;QACvE,4FAA4F;QAC5F,OAAO,SAAS,CAAC;KAClB;AACH,CAAC,CAAC","sourcesContent":["import { CapiVariableTypes, getCapiType } from '../../../../adaptivity/capi';\n\nexport interface TypeOption {\n  key: 'string' | 'number' | 'array' | 'boolean' | 'enum' | 'math' | 'parray';\n  text: string;\n  value: CapiVariableTypes;\n}\nexport const typeOptions: TypeOption[] = [\n  { key: 'string', text: 'String', value: CapiVariableTypes.STRING },\n  { key: 'number', text: 'Number', value: CapiVariableTypes.NUMBER },\n  { key: 'array', text: 'Array', value: CapiVariableTypes.ARRAY },\n  { key: 'boolean', text: 'Boolean', value: CapiVariableTypes.BOOLEAN },\n  { key: 'enum', text: 'Enum', value: CapiVariableTypes.ENUM },\n  { key: 'math', text: 'Math Expression', value: CapiVariableTypes.MATH_EXPR },\n  { key: 'parray', text: 'Point Array', value: CapiVariableTypes.ARRAY_POINT },\n];\n\nexport interface ActionOperatorOption {\n  key: 'equal' | 'add' | 'bind' | 'set';\n  text: string;\n  value: string;\n}\nexport const actionOperatorOptions: ActionOperatorOption[] = [\n  { key: 'equal', text: '=', value: '=' },\n  { key: 'add', text: 'Adding', value: 'adding' },\n  { key: 'bind', text: 'Bind To', value: 'bind to' },\n  { key: 'set', text: 'Setting To', value: 'setting to' },\n];\n\nexport interface ConditionOperatorOption {\n  key: string;\n  text: string;\n  value: string;\n}\nexport const conditionOperatorOptions: ConditionOperatorOption[] = [\n  { key: 'equal', text: '=', value: 'equal' },\n  { key: 'notEqual', text: '!=', value: 'notEqual' },\n  { key: 'lessThan', text: '<', value: 'lessThan' },\n  { key: 'lessThanInclusive', text: '<=', value: 'lessThanInclusive' },\n  { key: 'greaterThan', text: '>', value: 'greaterThan' },\n  { key: 'greaterThanInclusive', text: '>=', value: 'greaterThanInclusive' },\n  { key: 'in', text: 'In', value: 'in' },\n  { key: 'notIn', text: 'Not In', value: 'notIn' },\n  { key: 'contains', text: 'Contains', value: 'contains' },\n  { key: 'notContains', text: 'Not Contains', value: 'notContains' },\n  { key: 'containsAnyOf', text: 'Contains Any', value: 'containsAnyOf' },\n  {\n    key: 'notContainsAnyOf',\n    text: 'Not Contains Any',\n    value: 'notContainsAnyOf',\n  },\n  { key: 'containsOnly', text: 'Contains Only', value: 'containsOnly' },\n  { key: 'isAnyOf', text: 'Is Any Of', value: 'isAnyOf' },\n  { key: 'notIsAnyOf', text: 'Not Any Of', value: 'notIsAnyOf' },\n  { key: 'isNaN', text: 'Is NaN', value: 'isNaN' },\n  { key: 'equalWithTolerance', text: '~==', value: 'equalWithTolerance' },\n  {\n    key: 'notEqualWithTolerance',\n    text: '~!=',\n    value: 'notEqualWithTolerance',\n  },\n  { key: 'inRange', text: 'In Range', value: 'inRange' },\n  { key: 'notInRange', text: 'Not In Range', value: 'notInRange' },\n  {\n    key: 'containsExactly',\n    text: 'Contains Exactly',\n    value: 'containsExactly',\n  },\n  {\n    key: 'notContainsExactly',\n    text: 'Not Contains Exactly',\n    value: 'notContainsExactly',\n  },\n  { key: 'startsWith', text: 'Starts With', value: 'startsWith' },\n  { key: 'endsWith', text: 'Ends With', value: 'endsWith' },\n  { key: 'is', text: 'Is', value: 'is' },\n  { key: 'notIs', text: 'Not Is', value: 'notIs' },\n  { key: 'hasSameTerms', text: 'Has Same Terms', value: 'hasSameTerms' },\n  { key: 'hasDifferentTerms', text: 'Has Different Terms', value: 'hasDifferentTerms' },\n  { key: 'isEquivalentOf', text: 'Is Equivalent', value: 'isEquivalentOf' },\n  { key: 'notIsEquivalentOf', text: 'Is Not Equivalent', value: 'notIsEquivalentOf' },\n  { key: 'isExactly', text: 'Is Exactly', value: 'isExactly' },\n  { key: 'notIsExactly', text: 'Not Is Exactly', value: 'notIsExactly' },\n];\n\nexport interface ConditionTypeOperatorCombo {\n  type: CapiVariableTypes;\n  operators: string[];\n}\nexport const conditionTypeOperatorCombos: ConditionTypeOperatorCombo[] = [\n  { type: CapiVariableTypes.BOOLEAN, operators: ['equal', 'is'] },\n  {\n    type: CapiVariableTypes.ENUM,\n    operators: [\n      'equal',\n      'notEqual',\n      'is',\n      'notIs',\n      // these are not supported by the rules engine anyway, we don't have all the values typically for an enum\n      /* 'greaterThan',\n      'lessThan',\n      'greaterThanInclusive',\n      'lessThanInclusive',\n      'inRange',\n      'notInRange', */\n    ],\n  },\n  {\n    type: CapiVariableTypes.NUMBER,\n    operators: [\n      'equal',\n      'notEqual',\n      'isNaN',\n      'is',\n      'isAnyOf',\n      'notIs',\n      'greaterThan',\n      'lessThan',\n      'greaterThanInclusive',\n      'lessThanInclusive',\n      'equalWithTolerance',\n      'notEqualWithTolerance',\n      'inRange',\n      'notInRange',\n    ],\n  },\n  {\n    type: CapiVariableTypes.STRING,\n    operators: [\n      'equal',\n      'notEqual',\n      'is',\n      'notIs',\n      'isExactly',\n      'notIsExactly',\n      'contains',\n      'notContains',\n      'containsExactly',\n      'notContainsExactly',\n      'containsAnyOf',\n      'notContainsAnyOf',\n      'startsWith',\n      'endsWith',\n    ],\n  },\n  {\n    type: CapiVariableTypes.ARRAY,\n    operators: [\n      'equal',\n      'notEqual',\n      'is',\n      'notIs',\n      'contains',\n      'notContains',\n      'containsAnyOf',\n      'notContainsAnyOf',\n      'containsOnly',\n    ],\n  },\n  {\n    type: CapiVariableTypes.MATH_EXPR,\n    operators: [\n      'isExactly',\n      'notIsExactly',\n      'isEquivalentOf',\n      'notIsEquivalentOf',\n      'hasSameTerms',\n      'hasDifferentTerms',\n    ],\n  },\n  {\n    type: CapiVariableTypes.ARRAY_POINT,\n    operators: ['equal', 'notEqual', 'is', 'notIs', 'contains', 'notContains'],\n  },\n];\n\nexport const sessionVariables: Record<string, unknown> = {\n  attemptNumber: 0,\n  currentQuestionScore: 0,\n  graded: false,\n  questionTimeExceeded: false,\n  timeOnQuestion: 0,\n  timeStartQuestion: 0,\n  tutorialScore: 0,\n  visits: [],\n};\n\nexport const inferTypeFromOperatorAndValue = (operator: string, value: any): CapiVariableTypes => {\n  const typeCombos = conditionTypeOperatorCombos.filter((combo) =>\n    combo.operators.includes(operator),\n  );\n  // if there is only one type of value that supports this operator, then use that type (i.e. isNaN)\n  if (typeCombos.length === 1) {\n    return typeCombos[0].type;\n  } else {\n    // if there are multiple types of value that support this operator, then best guess based on the value type\n    const valueType = getCapiType(value);\n    // make sure that the value type is supported by the operator\n    // this might still be wrong, but at least it won't kill the operator\n    const supportedTypes = typeCombos.map((combo) => combo.type);\n    if (!supportedTypes.includes(valueType)) {\n      // in this case then ignore the value type and use the first type combo\n      return typeCombos[0].type;\n    }\n    // TODO: figure out how to tell that a STRING is an ENUM or a MATH_EXPR\n    // ALSO: strings can contain variables which can be other types, in that case we're hosed...\n    return valueType;\n  }\n};\n"]}