{"version":3,"file":"equality.js","sourceRoot":"","sources":["../../../../src/adaptivity/operators/equality.ts"],"names":[],"mappings":"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","sourcesContent":["import { parseBoolean, parseArray } from 'utils/common';\n\nexport const isAnyOfOperator = (factValue: any, value: any): boolean => {\n  const parsedValue = parseArray(value);\n  if (!Array.isArray(parsedValue)) {\n    return false;\n  }\n  return parsedValue.some((val) => isEqual(factValue, val));\n};\n\nexport const isEqual = (factValue: any, value: any): boolean => {\n  // There no point in moving forward if one of them are undefined\n  if (value === undefined || factValue === undefined) {\n    return false;\n  }\n\n  const typeOfValue = typeof value;\n  const typeOfFactValue = typeof factValue;\n  //the rules that check the actual numbers do NOT fire if the value is NaN or the text box isn't filled out.\n  //so `is not 32.06` should not fire true if the number is a NaN.\n  if (typeOfValue === 'number' && Number.isNaN(factValue)) {\n    return false;\n  }\n  if (Array.isArray(factValue)) {\n    let compareValue = value;\n    const updatedFactValue: any = parseArray(factValue);\n    let updatedValue = value;\n    //Need to parse before we check \"if\" condition else it will fail for cases where value = '[0,0]'.\n    if (!Array.isArray(value) && typeOfValue === 'number') {\n      updatedValue = `[${value}]`;\n    }\n    updatedValue = parseArray(updatedValue);\n    if (Array.isArray(updatedValue)) {\n      // ** We are doing this for the cases where factValue comes [2 , 5] but the values comes as ['2','5'] */\n      // ** DT - making sure that value is of array type else value.map() will throw error. */\n      compareValue = updatedValue.sort();\n    }\n\n    // ** DT - Sorting both arrays. depending upon user selection in UI the array sometimes comes\n    // ** like factValue=[2,5] and value = [5,2] which is right selection but it evaluates to false*/\n    updatedFactValue.sort();\n    //compareValue = [] & updatedFactValue = ['']\n    if (compareValue.toString() === updatedFactValue.toString()) {\n      return true;\n    }\n    return JSON.stringify(updatedFactValue) === JSON.stringify(compareValue);\n  }\n  // for boolean values,  factValue comes as true and value comes as 'true'\n  // and some factValue comes as 'true' and value comes as true\n  if (typeOfFactValue === 'boolean') {\n    return value.toString().toLowerCase() === 'true' ? true === factValue : false === factValue;\n  }\n  if (typeOfValue === 'boolean') {\n    return factValue.toString().toLowerCase() === 'true' ? true === value : false === value;\n  }\n  if (typeOfValue === 'string' && (value === 'true' || value === 'false')) {\n    return parseBoolean(value) === parseBoolean(factValue);\n  }\n  // For number type equality, factValue comes as '1' and value comes as 1 or vice versa\n  if (typeOfValue === 'number') {\n    return parseFloat(factValue) === value;\n  } else if (typeOfFactValue === 'number') {\n    return parseFloat(value) === factValue;\n  }\n  if (typeOfValue === 'string' && typeOfFactValue === 'string') {\n    return value.trim().toLowerCase() === factValue.trim().toLowerCase();\n  }\n  return factValue === value;\n};\n\nexport const notIsAnyOfOperator = (factValue: any, value: any) =>\n  !isAnyOfOperator(factValue, value);\n\nexport const isNaNOperator = (factValue: any, value: any) =>\n  parseBoolean(value) === (Number.parseFloat(factValue).toString() === 'NaN');\n\nexport const equalWithToleranceOperator = (factValue: any, value: any) => {\n  const modifiedFactValue = typeof factValue === 'string' ? parseFloat(factValue) : factValue;\n  /* console.log('EQT1', { factValue, value, modifiedFactValue }); */\n  let arrValue: any[];\n  try {\n    arrValue = parseArray(value);\n  } catch (e) {\n    return false;\n  }\n  if (Number.isNaN(modifiedFactValue)) {\n    return false;\n  }\n  const [baseValue, tolerance] = arrValue;\n  const valuesWithTolerance = getValueWithTolerance(baseValue, baseValue, tolerance);\n  const isInRange =\n    modifiedFactValue >= valuesWithTolerance.minToleranceValue &&\n    modifiedFactValue <= valuesWithTolerance.maxToleranceValue;\n  /* console.log('EQT2', {\n    factValue,\n    arrValue,\n    modifiedFactValue,\n    isInRange,\n    valuesWithTolerance,\n    baseValue,\n    tolerance,\n  }); */\n  return isInRange;\n};\n\nexport const getValueWithTolerance = (\n  baseMinValue: number,\n  baseMaxValue: number,\n  tolerance: number,\n) => {\n  let newValue = {\n    minToleranceValue: baseMinValue,\n    maxToleranceValue: baseMaxValue,\n  };\n  //If tolerance is not specified then do nothing and return the original values.\n  if (tolerance > 0) {\n    const calculateMinWithToleranceValue = (tolerance * baseMinValue) / 100;\n    const calculateMaxWithToleranceValue = (tolerance * baseMaxValue) / 100;\n    const minToleranceValue =\n      baseMinValue >= 0\n        ? baseMinValue - calculateMinWithToleranceValue\n        : baseMinValue + calculateMinWithToleranceValue;\n    const maxToleranceValue =\n      baseMinValue >= 0\n        ? baseMaxValue + calculateMaxWithToleranceValue\n        : baseMinValue - calculateMinWithToleranceValue;\n    newValue = {\n      minToleranceValue: minToleranceValue,\n      maxToleranceValue: maxToleranceValue,\n    };\n  }\n  return newValue;\n};\nexport const notEqualWithToleranceOperator = (factValue: any, value: any) =>\n  !equalWithToleranceOperator(factValue, value);\n\nexport const notEqual = (factValue: any, value: any) => {\n  const typeOfValue = typeof value;\n  //the rules that check the actual numbers do NOT fire if the value is NaN or the text box isn't filled out.\n  //so `is not 32.06` should not fire true if the number is a NaN.\n  if (typeOfValue === 'number' && Number.isNaN(factValue)) {\n    return false;\n  }\n  return !isEqual(factValue, value);\n};\n\nconst operators = {\n  isAnyOf: isAnyOfOperator,\n  notIsAnyOf: notIsAnyOfOperator,\n  isNaN: isNaNOperator,\n  equal: isEqual,\n  is: isEqual,\n  notIs: notEqual,\n  notEqual: notEqual,\n  equalWithTolerance: equalWithToleranceOperator,\n  notEqualWithTolerance: notEqualWithToleranceOperator,\n};\n\nexport default operators;\n"]}