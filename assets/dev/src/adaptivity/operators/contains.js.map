{"version":3,"file":"contains.js","sourceRoot":"","sources":["../../../../src/adaptivity/operators/contains.ts"],"names":[],"mappings":"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","sourcesContent":["import { isString, parseArray, parseNumString } from 'utils/common';\n\nconst handleContainsOperator = (\n  factValue: any,\n  value: any,\n  isDoesNotContainsOperator: boolean,\n  isContainsAnyOperator = false,\n) => {\n  // factValue contains value, can contain other items\n  if (!value || !factValue) {\n    return false;\n  }\n\n  if (isString(factValue)) {\n    if (!isString(value)) {\n      // use case: factValue = 'abc' and value = ['abc',' abc']\n      if (Array.isArray(value)) {\n        return value.some((item: any) => {\n          return factValue.trim().includes(item.trim());\n        });\n      }\n      return false;\n    }\n    // TODO there are inconsistencies between the what the sim puts out Wan-C wan-C\n    // Need to determine if we should force the sim to update or not to be consistent or be loose like this\n    if (!value.includes(`[`) && !value.includes(']')) {\n      return factValue.toLocaleLowerCase().includes(value.toLocaleLowerCase());\n    }\n    value = parseArray(value);\n    return value.some((item: any) => factValue.includes(item.trim()));\n  }\n\n  if (Array.isArray(factValue) && Array.isArray(value)) {\n    // We are parseNumString for the cases where factValue contains numbers but the values contain strings or vice-versa\n    const updatedFacts = parseArray(factValue);\n    const modifiedValue = parseArray(value);\n    if (isDoesNotContainsOperator) {\n      return (\n        modifiedValue\n          // check if value is found in factValue array\n          .every((item) => updatedFacts.includes(item))\n      );\n    } else {\n      let hitCount = 0; // counts the number of values found\n\n      modifiedValue.forEach((item) => {\n        if (updatedFacts.includes(item)) {\n          hitCount++;\n        }\n      });\n      if (isContainsAnyOperator && hitCount > 0) {\n        return true;\n      } else if (hitCount === modifiedValue.length) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else if (Array.isArray(factValue) && value) {\n    // We are parseArrayString for the cases where factValue contains strings but the values contain strings\n    const updatedFacts = parseArray(factValue);\n    const updatedValue = parseArray(value);\n    return updatedValue.some((item: any) => updatedFacts.includes(item));\n  }\n\n  return false;\n};\n\nexport const containsOperator = (factValue: any, value: any) => {\n  return handleContainsOperator(factValue, value, false);\n};\n\nexport const notContainsOperator = (factValue: any, value: any) =>\n  !handleContainsOperator(factValue, value, true);\n\nexport const containsAnyOfOperator = (factValue: any, value: any) =>\n  // factValue contains any items in value\n  handleContainsOperator(factValue, value, false, true);\n\nexport const notContainsAnyOfOperator = (factValue: any, value: any) =>\n  // factValue does not contain items in value\n  !handleContainsOperator(factValue, value, false, true);\n\nexport const containsOnlyOperator = (factValue: any, value: any) => {\n  // factValue contains ONLY items in value\n  if (!value || !factValue || (Array.isArray(factValue) && factValue.length < 1)) {\n    return false;\n  }\n\n  // We are parseNumString for the cases where factValue contains numbers but the values contain strings or vice-versa\n  const updatedFacts = parseArray(factValue);\n  const updatedValues = parseArray(value);\n\n  if (updatedValues.length !== updatedFacts.length) {\n    return false;\n  }\n\n  return updatedFacts.every((fact: any) => updatedValues.includes(fact));\n};\n\nexport const containsExactlyOperator = (factValue: any, value: any) => {\n  // factValue is exactly equal to value\n  if (!value || !factValue) {\n    return false;\n  }\n\n  // We are parseNumString for the cases where factValue contains numbers but the values contain strings or vice-versa\n  const updatedFacts = parseArray(factValue);\n  const updatedValues = parseArray(value);\n\n  if (Array.isArray(factValue) && Array.isArray(value)) {\n    return (\n      updatedFacts.every((fact) => updatedValues.includes(fact)) &&\n      updatedFacts.length == updatedValues.length\n    );\n  } else {\n    return factValue === value;\n  }\n};\n\nexport const notContainsExactlyOperator = (factValue: any, value: any) =>\n  !containsExactlyOperator(factValue, value);\n\nconst operators = {\n  contains: containsOperator,\n  notContains: notContainsOperator,\n  containsAnyOf: containsAnyOfOperator,\n  notContainsAnyOf: notContainsAnyOfOperator,\n  containsExactly: containsExactlyOperator,\n  notContainsExactly: notContainsExactlyOperator,\n  containsOnly: containsOnlyOperator,\n};\n\nexport default operators;\n"]}