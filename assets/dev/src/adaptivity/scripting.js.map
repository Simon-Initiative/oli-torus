{"version":3,"file":"scripting.js","sourceRoot":"","sources":["../../../src/adaptivity/scripting.ts"],"names":[],"mappings":"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","sourcesContent":["import { Environment, Evaluator, Lexer, Parser } from 'janus-script';\nimport { parseArray, parseBoolean } from 'utils/common';\nimport { CapiVariableTypes, getCapiType } from './capi';\nimport { janus_std } from './janus-scripts/builtin_functions';\n\nexport const looksLikeJson = (str: string) => {\n  const emptyJsonObj = '{}';\n  const jsonStart1 = '{\"';\n  const jsonStart2 = '{ \"';\n  const jsonEnd = '}';\n\n  const startsLikeJson = str.startsWith(jsonStart1) || str.startsWith(jsonStart2);\n  const endsLikeJson = str.endsWith(jsonEnd);\n\n  return str === emptyJsonObj || (startsLikeJson && endsLikeJson);\n};\n\nexport const getExpressionStringForValue = (\n  v: { type: CapiVariableTypes; value: any },\n  env: Environment = defaultGlobalEnv,\n): string => {\n  let val: any = v.value;\n  let isValueVar = false;\n\n  if (typeof val === 'string') {\n    let canEval = false;\n    try {\n      const test = evalScript(val, env);\n      canEval = test?.result !== undefined && !test.result.message;\n      /* console.log('can actually eval:', { val, canEval, test, t: typeof test.result }); */\n    } catch (e) {\n      // failed for any reason\n    }\n\n    const looksLikeAFunction = val.includes('(') && val.includes(')');\n\n    // we're assuming this is {stage.foo.whatever} as opposed to JSON {\"foo\": 1}\n    // note this will break if number keys are used {1:2} !!\n\n    const looksLikeJSON = looksLikeJson(val);\n    const hasCurlies = val.includes('{') && val.includes('}');\n\n    const hasBackslash = val.includes('\\\\');\n    isValueVar =\n      (canEval && !looksLikeJSON && looksLikeAFunction && !hasBackslash) ||\n      (hasCurlies && !looksLikeJSON && !hasBackslash);\n  }\n\n  if (isValueVar) {\n    // PMP-750 support expression arrays\n    if (val[0] === '[' && val[1] === '{' && (val.includes('},{') || val.includes('}, {'))) {\n      val = val.replace(/[[\\]]+/g, '');\n    }\n    if (val.includes('},{') || val.includes('}, {')) {\n      val = JSON.stringify(val.split(',')).replace(/\"/g, '');\n    }\n\n    // it might be CSS string, which can be decieving\n    let actuallyAString = false;\n    const expressions = extractAllExpressionsFromText(val);\n    // A expression will not have a ';' inside it. So if there is a ';' inside it, it is CSS.\n    const isCSSString = expressions.filter((e) => e.includes(';'));\n    if (isCSSString?.length) {\n      actuallyAString = true;\n    }\n    if (!actuallyAString) {\n      try {\n        const testEnv = new Environment(env);\n        const testResult = evalScript(`let foo = ${val};`, testEnv);\n        if (testResult?.result !== null) {\n          //expression {stage.foo} + {stage.bar} was failling if we set actuallyAString= true\n          actuallyAString = expressions?.length ? false : true;\n        }\n      } catch (e) {\n        // if we have parsing error then we're guessing it's CSS\n        actuallyAString = true;\n      }\n    }\n    if (!actuallyAString) {\n      return `${val}`;\n    }\n  }\n\n  if (\n    v.type === CapiVariableTypes.STRING ||\n    v.type === CapiVariableTypes.ENUM ||\n    v.type === CapiVariableTypes.MATH_EXPR\n  ) {\n    if (typeof val !== 'string') {\n      val = JSON.stringify(val);\n    }\n    // strings need to have escaped quotes and backslashes\n    // for janus-script\n    val = `\"${val.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '')}\"`;\n  }\n\n  if (v.type === CapiVariableTypes.ARRAY || v.type === CapiVariableTypes.ARRAY_POINT) {\n    val = JSON.stringify(parseArray(val));\n  }\n\n  if (v.type === CapiVariableTypes.NUMBER) {\n    // val = convertExponentialToDecimal(val);\n    val = parseFloat(val);\n    if (val === '') {\n      val = 'null';\n    }\n  }\n\n  if (v.type === CapiVariableTypes.BOOLEAN) {\n    val = parseBoolean(val);\n  }\n\n  if (typeof val === 'object') {\n    val = JSON.stringify(val);\n  }\n\n  if (!v.type || v.type === CapiVariableTypes.UNKNOWN) {\n    if (typeof v.value === 'object' && Array.isArray(v.value)) {\n      val = JSON.stringify(v.value);\n    } else if (typeof val === 'string' && val[0] !== '\"' && val.slice(-1) !== '\"') {\n      val = `\"${val}\"`;\n    }\n  }\n\n  return `${val}`;\n};\n\nexport const evalScript = (\n  script: string,\n  env?: Environment,\n): { env: Environment; result: any } => {\n  const globalEnv = env || new Environment();\n  const evaluator = new Evaluator();\n  const lexer = new Lexer(script);\n  const parser = new Parser(lexer);\n  const program = parser.parseProgram();\n  if (parser.errors.length) {\n    /* console.error(`ERROR SCRIPT: ${script}`, { e: parser.errors }); */\n    throw new Error(`Error in script: ${script}\\n${parser.errors.join('\\n')}`);\n  }\n  const result = evaluator.eval(program, globalEnv);\n  let jsResult = result.toJS();\n  if (jsResult === 'null') {\n    jsResult = null;\n  }\n  //if a variable has bindTo operator applied on this then we get a error that we can ignore\n  // sometimes jsResult?.message?.indexOf('is a bound reference, cannot assign') is undefined so jsResult?.message?.indexOf('is a bound reference, cannot assign') !== -1 return true which we want to avoid hence checking > 0\n  if (jsResult?.message?.indexOf('is a bound reference, cannot assign') > 0) {\n    return { env: globalEnv, result: null };\n  }\n  return { env: globalEnv, result: jsResult };\n};\n\nexport const evalAssignScript = (\n  state: Record<string, any>,\n  env?: Environment,\n): { env: Environment; result: any } => {\n  const globalEnv = env || new Environment();\n  const assignStatements = getAssignStatements(state, globalEnv);\n  const results = assignStatements.map((assignStatement) => {\n    return evalScript(assignStatement, globalEnv).result;\n  });\n  return { env: globalEnv, result: results };\n};\n\nexport const getAssignStatements = (\n  state: Record<string, any>,\n  env: Environment = defaultGlobalEnv,\n): string[] => {\n  const vars = Object.keys(state).map((key) => {\n    const val = state[key];\n    let writeVal = { key, value: val, type: 0 };\n    // if it's already a capi var like object\n    if (val && val.constructor && val.constructor === Object) {\n      if (val.key || val.path) {\n        // the path should be a full key like stage.foo.text\n        writeVal = { ...val, key: val.path ? val.path : val.key };\n      } else {\n        writeVal.value = JSON.stringify(val);\n      }\n    }\n    if (!writeVal.type) {\n      writeVal.type = getCapiType(writeVal.value);\n    }\n    return writeVal;\n  });\n  const letStatements = vars.map(\n    (v) => `let {${v.key.trim()}} = ${getExpressionStringForValue(v, env)};`,\n  );\n  return letStatements;\n};\n\nexport const getAssignScript = (\n  state: Record<string, any>,\n  env: Environment = defaultGlobalEnv,\n): string => {\n  const letStatements = getAssignStatements(state, env);\n  return letStatements.join('');\n};\n\nexport const getEnvState = (env: Environment): Record<string, any> => {\n  // filter out functions, TODO: should do this perhaps in the lib instead?\n  const dump: any = env.toObj();\n  const filtered = Object.keys(dump).reduce((collect: any, key) => {\n    const value = dump[key];\n    if (typeof value !== 'function') {\n      collect[key] = value;\n    }\n    return collect;\n  }, {});\n  return filtered;\n};\n\nexport const getValues = (identifiers: string[], env?: Environment) => {\n  const jIds = identifiers.map((id) => `{${id}}`);\n  const script = `[${jIds.join(',')}]`;\n  const { result } = evalScript(script, env);\n  return result;\n};\n\nexport const getValue = (identifier: string, env?: Environment) => {\n  const script = `{${identifier}}`;\n  const { result } = evalScript(script, env);\n  return result;\n};\n\nexport interface ApplyStateOperation {\n  id?: string;\n  target: string;\n  operator: string;\n  value: any;\n  type?: CapiVariableTypes;\n  targetType?: CapiVariableTypes;\n}\n\nexport const applyState = (\n  operation: ApplyStateOperation,\n  env: Environment = defaultGlobalEnv,\n): any => {\n  const targetKey = operation.target.trim();\n  const targetType = operation.type || operation.targetType || CapiVariableTypes.UNKNOWN;\n  let errorMsg = '';\n  let script = `let {${targetKey}} `;\n  switch (operation.operator) {\n    case 'adding':\n    case '+':\n      script += `= {${targetKey}} + ${getExpressionStringForValue(\n        {\n          value: operation.value,\n          type: targetType,\n        },\n        env,\n      )};`;\n      break;\n    case 'subtracting':\n    case '-':\n      script += `= {${targetKey}} - ${getExpressionStringForValue(\n        {\n          value: operation.value,\n          type: targetType,\n        },\n        env,\n      )};`;\n      break;\n    case 'bind to':\n      // NOTE: once a value is bound, you can *never* set it other than through binding????\n      // at least right now otherwise it will just overwrite the binding\n      // binding is a special case, it MUST be a string because it's binding to a variable\n      // it should not be wrapped in curlies already\n      if (typeof operation.value !== 'string') {\n        errorMsg = `bind to value must be a string, got ${typeof operation.value}`;\n        break;\n      }\n      if (operation.value[0] === '{' && operation.value.slice(-1) === '}') {\n        script += `= ${operation.value};`;\n      } else {\n        script += `&= {${operation.value}};`;\n      }\n      break;\n    case 'setting to':\n    case '=':\n      script = `let {${targetKey}} = ${getExpressionStringForValue(\n        {\n          value: operation.value,\n          type: targetType,\n        },\n        env,\n      )};`;\n      break;\n    default:\n      errorMsg = `Unknown applyState operator ${JSON.stringify(operation.operator)}!`;\n      console.warn(errorMsg, {\n        operation,\n      });\n      break;\n  }\n  let result;\n  if (errorMsg) {\n    result = { env, result: { error: true, message: errorMsg, details: operation } };\n  } else {\n    result = evalScript(script, env);\n  }\n  if (result.result) {\n    console.log('APPLY STATE RESULTS: ', { script, result });\n  }\n  return result;\n};\n\nexport const bulkApplyState = (\n  operations: ApplyStateOperation[],\n  env: Environment = defaultGlobalEnv,\n): any[] => {\n  // need to apply one at a time, TODO: break on error?\n  return operations.map((op) => applyState(op, env));\n};\n\nexport const removeStateValues = (env: Environment, keys: string[]): void => {\n  env.remove(keys);\n};\n\nexport const getLocalizedStateSnapshot = (\n  activityIds: string[],\n  env: Environment = defaultGlobalEnv,\n) => {\n  const snapshot = getEnvState(env);\n  const finalState: any = { ...snapshot };\n  activityIds.forEach((activityId: string) => {\n    const activityState = Object.keys(snapshot)\n      .filter((key) => key.indexOf(`${activityId}|stage.`) === 0)\n      .reduce((collect: any, key) => {\n        const localizedKey = key.replace(`${activityId}|`, '');\n        collect[localizedKey] = snapshot[key];\n        return collect;\n      }, {});\n    Object.assign(finalState, activityState);\n  });\n  return finalState;\n};\n\n// function to select the content between only the outermost {}\nexport const extractExpressionFromText = (text: string) => {\n  const firstCurly = text.indexOf('{');\n  let lastCurly = -1;\n  let counter = 1;\n  let opens = 1;\n  while (counter < text.length && lastCurly === -1) {\n    if (text[firstCurly + counter] === '{') {\n      opens++;\n    } else if (text[firstCurly + counter] === '}') {\n      opens--;\n      if (opens === 0) {\n        lastCurly = firstCurly + counter;\n      }\n    }\n    counter++;\n  }\n  return text.substring(firstCurly + 1, lastCurly);\n};\n\n// extract all expressions from a string\nexport const extractAllExpressionsFromText = (text: string): string[] => {\n  const expressions = [];\n  if (text.indexOf('{') !== -1 && text.indexOf('}') !== -1) {\n    const expr = extractExpressionFromText(text);\n    const rest = text.substring(text.indexOf(expr) + expr.length + 1);\n    expressions.push(expr);\n    expressions.push(...extractAllExpressionsFromText(rest));\n  }\n  return expressions;\n};\n\n// for use by client side scripting evalution\nexport const defaultGlobalEnv = new Environment();\n// note: CANNOT have this window reference in the shared nodejs code\n/* (window as any)['defaultGlobalEnv'] = defaultGlobalEnv; */\n// load std lib\nevalScript(janus_std, defaultGlobalEnv);\n"]}