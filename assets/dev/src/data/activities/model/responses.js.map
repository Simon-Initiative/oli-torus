{"version":3,"file":"responses.js","sourceRoot":"","sources":["../../../../../src/data/activities/model/responses.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ChoiceId,\n  ChoiceIdsToResponseId,\n  HasParts,\n  makeResponse,\n  Response,\n} from 'components/activities/types';\nimport { containsRule, eqRule, matchRule } from 'data/activities/model/rules';\nimport { getByUnsafe, getPartById } from 'data/activities/model/utils';\nimport { Maybe } from 'tsmonad';\nimport { Operations } from 'utils/pathOperations';\n\nexport const Responses = {\n  catchAll: (text = 'Incorrect') => makeResponse(matchRule('.*'), 0, text),\n  forTextInput: (correctText = 'Correct', incorrectText = 'Incorrect') => [\n    makeResponse(containsRule('answer'), 1, correctText),\n    Responses.catchAll(incorrectText),\n  ],\n  forNumericInput: (correctText = 'Correct', incorrectText = 'Incorrect') => [\n    makeResponse(eqRule('1'), 1, correctText),\n    Responses.catchAll(incorrectText),\n  ],\n  forMultipleChoice: (\n    correctChoiceId: ChoiceId,\n    correctText = 'Correct',\n    incorrectText = 'Incorrect',\n  ) => [\n    makeResponse(matchRule(correctChoiceId), 1, correctText),\n    makeResponse(matchRule('.*'), 0, incorrectText),\n  ],\n};\n\nexport const RESPONSES_PATH = '$..responses';\nexport const getResponses = (model: HasParts, path = RESPONSES_PATH): Response[] =>\n  Operations.apply(model, Operations.find(path));\n\nexport const getResponsesByPartId = (model: HasParts, partId: string): Response[] =>\n  getPartById(model, partId).responses;\n\nexport const getResponseBy = (model: HasParts, predicate: (x: Response) => boolean) =>\n  getByUnsafe(getResponses(model), predicate);\n\n// Does not take into account partial credit\nexport const getCorrectResponse = (model: HasParts, partId: string) => {\n  return Maybe.maybe(getResponsesByPartId(model, partId).find((r) => r.score === 1)).valueOrThrow(\n    new Error('Could not find correct response'),\n  );\n};\nexport const getIncorrectResponse = (model: HasParts, partId: string) => {\n  return Maybe.maybe(\n    getResponsesByPartId(model, partId).find((r) => r.rule === matchRule('.*')),\n  ).valueOrThrow(new Error('Could not find incorrect response'));\n};\n\nexport interface ResponseMapping {\n  response: Response;\n  choiceIds: ChoiceId[];\n}\nexport const getTargetedResponseMappings = (\n  model: HasParts & {\n    authoring: { targeted: ChoiceIdsToResponseId[] };\n  },\n): ResponseMapping[] =>\n  model.authoring.targeted.map((assoc) => ({\n    response: getResponseBy(model, (r) => r.id === getResponseId(assoc)),\n    choiceIds: getChoiceIds(assoc),\n  }));\n\n// Choices\nexport const getChoiceIds = ([choiceIds]: ChoiceIdsToResponseId) => choiceIds;\nexport const getCorrectChoiceIds = (model: { authoring: { correct: ChoiceIdsToResponseId } }) =>\n  getChoiceIds(model.authoring.correct);\nexport const getIncorrectChoiceIds = (model: { authoring: { incorrect: ChoiceIdsToResponseId } }) =>\n  getChoiceIds(model.authoring.incorrect);\nexport const getTargetedChoiceIds = (model: { authoring: { targeted: ChoiceIdsToResponseId[] } }) =>\n  model.authoring.targeted.map(getChoiceIds);\nexport const isCorrectChoice = (\n  model: { authoring: { correct: ChoiceIdsToResponseId } },\n  choiceId: ChoiceId,\n) => getCorrectChoiceIds(model).includes(choiceId);\n\n// Responses\nexport const getResponseId = ([, responseId]: ChoiceIdsToResponseId) => responseId;\nexport const getTargetedResponses = (\n  model: HasParts & { authoring: { targeted: ChoiceIdsToResponseId[] } },\n) =>\n  model.authoring.targeted.map((assoc) =>\n    getResponseBy(model, (r) => r.id === getResponseId(assoc)),\n  );\n"]}