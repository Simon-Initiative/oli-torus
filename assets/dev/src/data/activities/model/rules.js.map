{"version":3,"file":"rules.js","sourceRoot":"","sources":["../../../../../src/data/activities/model/rules.ts"],"names":[],"mappings":"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","sourcesContent":["import { setDifference } from 'components/activities/common/utils';\nimport { Response } from 'components/activities/types';\nimport { Maybe } from 'tsmonad';\n\nexport const invertRule = (rule: string) => `(!(${rule}))`;\n\nconst andTwoRules = (rule1: string, rule2: string) => `${rule2} && (${rule1})`;\nexport const andRules = (...rules: string[]) => rules.reduce(andTwoRules);\n\nconst orTwoRules = (rule1: string, rule2: string) => `${rule2} || (${rule1})`;\nexport const orRules = (...rules: string[]) => rules.reduce(orTwoRules);\n\nexport const isCatchAllResponse = (response: Response) => response.rule === '.*';\n\nexport type RuleOperator =\n  // text\n  | 'contains'\n  | 'notcontains'\n  | 'regex'\n  // numeric\n  | 'gt'\n  | 'gte'\n  | 'eq'\n  | 'lt'\n  | 'lte'\n  | 'neq'\n  | 'btw'\n  | 'nbtw';\n\nexport function isOperator(s: string): s is RuleOperator {\n  return [\n    'contains',\n    'notcontains',\n    'regex',\n    'gt',\n    'gte',\n    'eq',\n    'lt',\n    'lte',\n    'neq',\n    'btw',\n    'nbtw',\n  ].includes(s);\n}\n\n// text\nexport const matchRule = (input: string) => `input like {${input}}`;\nexport const containsRule = (input: string) => `input contains {${input}}`;\nexport const notContainsRule = (input: string) => invertRule(containsRule(input));\n\n// numeric\nexport const eqRule = (input: string) => `input = {${input}}`;\nexport const neqRule = (input: string) => invertRule(eqRule(input));\nexport const ltRule = (input: string) => `input < {${input}}`;\nexport const lteRule = (input: string) => orRules(ltRule(input), eqRule(input));\nexport const gtRule = (input: string) => `input > {${input}}`;\nexport const gteRule = (input: string) => orRules(gtRule(input), eqRule(input));\n\nconst makeBtwRule = (lesser: string, greater: string) =>\n  andRules(orRules(gtRule(lesser), eqRule(lesser)), orRules(ltRule(greater), eqRule(greater)));\n\nexport const btwRule = (left: string, right: string) => {\n  const parsedLeft = parseFloat(left);\n  const parsedRight = parseFloat(right);\n  if (Number.isNaN(parsedLeft) || Number.isNaN(parsedRight)) {\n    return makeBtwRule('0', '0');\n  }\n\n  const lesser = parsedLeft < parsedRight ? left : right;\n  const greater = lesser === left ? right : left;\n  return makeBtwRule(lesser, greater);\n};\nexport const nbtwRule = (left: string, right: string) => invertRule(btwRule(left, right));\n\nexport const makeRule = (operator: RuleOperator, input: string | [string, string]) => {\n  if (typeof input === 'string') {\n    switch (operator) {\n      case 'gt':\n        return gtRule(input);\n      case 'gte':\n        return gteRule(input);\n      case 'lt':\n        return ltRule(input);\n      case 'lte':\n        return lteRule(input);\n      case 'eq':\n        return eqRule(input);\n      case 'neq':\n        return neqRule(input);\n      case 'contains':\n        return containsRule(input);\n      case 'notcontains':\n        return notContainsRule(input);\n      case 'regex':\n        return matchRule(input);\n    }\n  }\n  switch (operator) {\n    case 'btw':\n      return btwRule(input[0], input[1]);\n    case 'nbtw':\n      return nbtwRule(input[0], input[1]);\n  }\n  throw new Error('Could not make numeric rule for operator ' + operator + ' and input ' + input);\n};\n\n// Look for two equality matches, something like `input = {123} || input = {234}`\nconst matchBetweenRule = (rule: string) => rule.match(/= {(\\d+)}.* = {(\\d+)}/);\nexport const parseInputFromRule = (rule: string) =>\n  Maybe.maybe(matchBetweenRule(rule)).caseOf<string | [string, string]>({\n    just: (betweenMatch) => [betweenMatch[1], betweenMatch[2]],\n    nothing: () => parseSingleInput(rule),\n  });\n\nexport const parseSingleInput = (rule: string) =>\n  rule.substring(rule.indexOf('{') + 1, rule.indexOf('}'));\n\nexport const parseOperatorFromRule = (rule: string): RuleOperator => {\n  switch (true) {\n    // text\n    case rule.includes('!') && rule.includes('contains'):\n      return 'notcontains';\n    case rule.includes('contains'):\n      return 'contains';\n    case rule.includes('like'):\n      return 'regex';\n\n    // numeric\n    case ['!', '>', '<', '='].every((op) => rule.includes(op)):\n      return 'nbtw';\n    case ['>', '<', '='].every((op) => rule.includes(op)):\n      return 'btw';\n    case rule.includes('>') && rule.includes('='):\n      return 'gte';\n    case rule.includes('>'):\n      return 'gt';\n    case rule.includes('<') && rule.includes('='):\n      return 'lte';\n    case rule.includes('<'):\n      return 'lt';\n    case rule.includes('!') && rule.includes('='):\n      return 'neq';\n    case rule.includes('='):\n      return 'eq';\n    default:\n      throw new Error('Operator could not be found in rule ' + rule);\n  }\n};\n\nexport const isTextRule = (rule: string): boolean =>\n  !!rule.match(/contains/) || !!rule.match(/like/);\n\n// Explicitly match all ids in `toMatch` and do not match any ids in `allChoiceIds` \\ `toMatch`\nexport const matchListRule = (all: string[], toMatch: string[]) => {\n  const notToMatch = setDifference(all, toMatch);\n  return andRules(\n    ...toMatch.map(matchRule).concat(notToMatch.map((id) => invertRule(matchRule(id)))),\n  );\n};\n\n// Match the `ordered` list in exactly that order\nexport const matchInOrderRule = (ordered: string[]) => `input like {${ordered.join(' ')}}`;\n"]}