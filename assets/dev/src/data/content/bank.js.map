{"version":3,"file":"bank.js","sourceRoot":"","sources":["../../../../src/data/content/bank.ts"],"names":[],"mappings":"AAkBA,MAAM,CAAN,IAAY,cAGX;AAHD,WAAY,cAAc;IACxB,6BAAW,CAAA;IACX,6BAAW,CAAA;AACb,CAAC,EAHW,cAAc,KAAd,cAAc,QAGzB;AAED,MAAM,CAAN,IAAY,kBAKX;AALD,WAAY,kBAAkB;IAC5B,2CAAqB,CAAA;IACrB,yDAAmC,CAAA;IACnC,uCAAiB,CAAA;IACjB,qDAA+B,CAAA;AACjC,CAAC,EALW,kBAAkB,KAAlB,kBAAkB,QAK7B;AAED,MAAM,CAAN,IAAY,IAKX;AALD,WAAY,IAAI;IACd,iCAAyB,CAAA;IACzB,qBAAa,CAAA;IACb,qBAAa,CAAA;IACb,qBAAa,CAAA;AACf,CAAC,EALW,IAAI,KAAJ,IAAI,QAKf;AAiBD,MAAM,UAAU,YAAY;IAC1B,OAAO;QACL,UAAU,EAAE,IAAI;KACjB,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,MAAM,CAAC,MAAc,EAAE,KAAa;IAClD,OAAO;QACL,MAAM;QACN,KAAK;KACN,CAAC;AACJ,CAAC;AAED,SAAS,YAAY,CAAC,KAAU;IAC9B,IAAI,KAAK,KAAK,IAAI,EAAE;QAClB,OAAO,IAAI,CAAC;KACb;SAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QACpC,OAAO,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC;KAC5B;SAAM,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,IAAI,CAAC;KACb;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,iFAAiF;AACjF,qFAAqF;AACrF,oFAAoF;AACpF,8DAA8D;AAC9D,EAAE;AACF,4EAA4E;AAC5E,wEAAwE;AACxE,EAAE;AACF,+BAA+B;AAC/B,sEAAsE;AACtE,oEAAoE;AACpE,4CAA4C;AAC5C,+EAA+E;AAC/E,mGAAmG;AACnG,oCAAoC;AACpC,yFAAyF;AACzF,uFAAuF;AACvF,wCAAwC;AACxC,6CAA6C;AAC7C,MAAM,UAAU,kBAAkB,CAAC,KAAY;IAC7C,IAAI,KAAK,CAAC,UAAU,KAAK,IAAI,EAAE;QAC7B,OAAO,KAAK,CAAC;KACd;IACD,IACE,KAAK,CAAC,UAAU,CAAC,QAAQ,KAAK,cAAc,CAAC,GAAG;QAChD,KAAK,CAAC,UAAU,CAAC,QAAQ,KAAK,cAAc,CAAC,GAAG,EAChD;QACA,MAAM,QAAQ,GAAI,KAAK,CAAC,UAAU,CAAC,QAAgB,CAAC,MAAM,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QAC/F,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;SAC7B;aAAM,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,OAAO,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;SACpC;aAAM;YACL,OAAO,EAAE,UAAU,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC;SAC1E;KACF;SAAM;QACL,IAAI,YAAY,CAAE,KAAK,CAAC,UAAkB,CAAC,KAAK,CAAC,EAAE;YACjD,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;SAC7B;KACF;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import { ResourceId } from 'data/types';\nimport { ObjectiveMap } from './activity';\n\nexport interface Logic {\n  conditions: null | Expression | Clause;\n}\n\nexport interface Expression {\n  fact: Fact;\n  operator: ExpressionOperator;\n  value: string[] | number[] | string;\n}\n\nexport interface Clause {\n  operator: ClauseOperator;\n  children: Clause[] | Expression[];\n}\n\nexport enum ClauseOperator {\n  all = 'all',\n  any = 'any',\n}\n\nexport enum ExpressionOperator {\n  contains = 'contains',\n  doesNotContain = 'does_not_contain',\n  equals = 'equals',\n  doesNotEqual = 'does_not_equal',\n}\n\nexport enum Fact {\n  objectives = 'objectives',\n  tags = 'tags',\n  text = 'text',\n  type = 'type',\n}\n\nexport interface Paging {\n  offset: number;\n  limit: number;\n}\n\nexport interface BankedActivity {\n  content: any;\n  title: string;\n  objectives: ObjectiveMap;\n  tags: ResourceId[];\n  resource_id: number;\n  activity_type_id: number;\n  slug: string;\n}\n\nexport function defaultLogic(): Logic {\n  return {\n    conditions: null,\n  };\n}\n\nexport function paging(offset: number, limit: number): Paging {\n  return {\n    offset,\n    limit,\n  };\n}\n\nfunction isEmptyValue(value: any) {\n  if (value === null) {\n    return true;\n  } else if (typeof value === 'string') {\n    return value.trim() === '';\n  } else if (value.length === 0) {\n    return true;\n  }\n  return false;\n}\n\n// The idea here is to take a logic expression and adjust it to guarantee that it\n// will not produce an error when executed on the server.  Any expression whose value\n// is empty (an empty array or zero length string) will cause an error, so this impl\n// seeks to find them and adjust to account for their removal.\n//\n// We leverage the fact that the UI is restricting logic to only contain one\n// clause, so to guarantee validity we do not need a recursive solution.\n//\n// Here are the cases we check:\n// 1. If the logic conditions are null, they are valid and we are done\n// 2. If the logic conditions is a clause, then filter to leave only\n//    expressions whose values are not empty\n//    a. If there are no expressions left, return a logic with null conditions.\n//    b. If there is only one expression, return a logic that has the outer clause removed, leaving\n//       just the single expression.\n//    b. Otherwise, return the logic with the clause in place with the filtered children.\n// 3. If the logic conditions is just an expression and that expression value is empty,\n//    return logic with null conditions.\n// 4. All other cases, return the logic as-is\nexport function guaranteeValididty(logic: Logic) {\n  if (logic.conditions === null) {\n    return logic;\n  }\n  if (\n    logic.conditions.operator === ClauseOperator.all ||\n    logic.conditions.operator === ClauseOperator.any\n  ) {\n    const children = (logic.conditions.children as any).filter((e: any) => !isEmptyValue(e.value));\n    if (children.length === 0) {\n      return { conditions: null };\n    } else if (children.length === 1) {\n      return { conditions: children[0] };\n    } else {\n      return { conditions: Object.assign({}, logic.conditions, { children }) };\n    }\n  } else {\n    if (isEmptyValue((logic.conditions as any).value)) {\n      return { conditions: null };\n    }\n  }\n\n  return logic;\n}\n"]}