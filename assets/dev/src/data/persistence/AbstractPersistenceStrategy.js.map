{"version":3,"file":"AbstractPersistenceStrategy.js","sourceRoot":"","sources":["../../../../src/data/persistence/AbstractPersistenceStrategy.ts"],"names":[],"mappings":"AAoBA,MAAM,OAAgB,2BAA2B;IAC/C;QACE,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAC5B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAC5B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;QAClC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,EAAE,IAAI,EAAE,cAAc,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;IACvD,CAAC;IAED,aAAa;QACX,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,WAAW;QACT,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;IAC1B,CAAC;IAED;;;OAGG;IACH,UAAU,CACR,MAAiC,EACjC,SAAoC,EACpC,SAAkC,EAClC,SAA4B,EAC5B,aAAoC;QAEpC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,mBAAmB,GAAG,aAAa,CAAC;QACzC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAE3B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM,EAAE,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;gBACvB,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;gBACzB,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;YACtC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAWD;;;OAGG;IACH,OAAO;QACL,4EAA4E;QAC5E,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE;YACrB,wCAAwC;YACxC,IAAI,CAAC,WAAW,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["import { LockResult } from './lock';\n\nimport {\n  onFailureCallback,\n  onSaveCompletedCallback,\n  onStateChangeCallback,\n  PersistenceStrategy,\n} from './PersistenceStrategy';\n\nexport interface AbstractPersistenceStrategy {\n  successCallback: onSaveCompletedCallback | null;\n  failureCallback: onFailureCallback | null;\n  stateChangeCallback: onStateChangeCallback | null;\n  writeLockedDocumentId: string | null;\n  courseId: string | null;\n  destroyed: boolean;\n  lockResult: LockResult;\n  releaseFn: () => Promise<LockResult>;\n}\n\nexport abstract class AbstractPersistenceStrategy implements PersistenceStrategy {\n  constructor() {\n    this.successCallback = null;\n    this.failureCallback = null;\n    this.stateChangeCallback = null;\n    this.writeLockedDocumentId = null;\n    this.courseId = null;\n    this.destroyed = false;\n    this.lockResult = { type: 'not_acquired', user: '' };\n  }\n\n  getLockResult(): LockResult {\n    return this.lockResult;\n  }\n\n  releaseLock() {\n    return this.releaseFn();\n  }\n\n  /**\n   * This strategy requires the user to acquire the write lock before\n   * editing.\n   */\n  initialize(\n    lockFn: () => Promise<LockResult>,\n    releaseFn: () => Promise<LockResult>,\n    onSuccess: onSaveCompletedCallback,\n    onFailure: onFailureCallback,\n    onStateChange: onStateChangeCallback,\n  ): Promise<boolean> {\n    this.successCallback = onSuccess;\n    this.failureCallback = onFailure;\n    this.stateChangeCallback = onStateChange;\n    this.releaseFn = releaseFn;\n\n    return new Promise((resolve, reject) => {\n      lockFn().then((result) => {\n        this.lockResult = result;\n        resolve(result.type === 'acquired');\n      });\n    });\n  }\n\n  abstract save(saveFn: any): void;\n  abstract saveImmediate(saveFn: any): void;\n\n  /**\n   * Method to that child classes must implement to allow an async\n   *\n   */\n  abstract doDestroy(): boolean;\n\n  /**\n   * Indicate to the persistence strategy that it is being shutdown and that it\n   * should clean up any resources and flush any pending changes immediately.\n   */\n  destroy() {\n    // If we had a pending change that released the lock, doDestroy returns true\n    if (!this.doDestroy()) {\n      // We need to explicity release the lock\n      this.releaseLock();\n    }\n  }\n}\n"]}