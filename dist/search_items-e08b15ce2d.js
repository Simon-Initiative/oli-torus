searchNodes=[{"doc":"A managed instance of Torus is available at https://proton.oli.cmu.edu where one can create an account, create a course project and begin authoring.","ref":"end-user.html","title":"As a new user","type":"extras"},{"doc":"These instructions will set up a development environment with the Torus server running directly on the host machine.","ref":"developer.html","title":"As a developer","type":"extras"},{"doc":"Install dependencies: Docker and docker-compose Elixir ( $ brew install elixir ) Phoenix ( $ mix archive.install hex phx_new 1.5.9 ) Clone this repository $ git clone https://github.com/Simon-Initiative/oli-torus Run $ sh ./devmode.sh Run $ mix phx.server Open your web browser to https://localhost .","ref":"developer.html#mostly-automated-steps","title":"As a developer - Mostly Automated Steps","type":"extras"},{"doc":"Install dependencies: Docker and docker-compose Elixir ( $ brew install elixir ) Phoenix ( $ mix archive.install hex phx_new 1.5.9 ) Clone this repository $ git clone https://github.com/Simon-Initiative/oli-torus Create configuration env files: $ cp oli.example.env oli.env $ cp postgres.example.env postgres.env Configure oli.env for running natively: REPLACE: DB_HOST = postgres WITH: DB_HOST = localhost Start dockerized postgres 12 via the included docker-compose file: $ docker-compose up -d postgres Install server and client dependencies: $ mix deps.get $ cd assets &amp;&amp; yarn Create database $ cd ../ &amp;&amp; mix ecto.create Run migration to create schema $ mix ecto.migrate Seed the database $ mix run priv/repo/seeds.exs Configure bash to properly source environment variable configurations $ set -a Load phoenix app configuration from environment file. This step is necessary anytime you change a configuration variable $ source oli.env Start Phoenix server $ mix phx.server Note : Use Ctrl+c to stop the Phoenix server Open your web browser to https://localhost . Notes In order to sign in, you must use https and accept the self-signed cert browser warning to avoid CSRF issues. If you would like to provide your own cert instead of accepting the included one, simply replace priv/ssl/localhost.crt -or- use the localhost tunneling method below to generate a public URL with SSL enabled. Docker is not a strict dependency. We use it here to simplify the install and running of Postgres. You can choose to install and run Postgres bare-metal, but you will not be able to use the Mostly Automated Steps above (since the ./devmode.sh script depends on Docker).","ref":"developer.html#mostly-manual-steps","title":"As a developer - Mostly Manual Steps","type":"extras"},{"doc":"Note : If you are running using docker-compose as described in Quick Start , you can create a bash session to execute any of the following commands using docker-compose exec app bash Run JavaScript tests $ cd assets &amp;&amp; npm run test Run elixir tests $ mix test Run elixir tests for a specific file, watch for changes and automatically re-run tests $ mix test.watch --stale --max-failures 1 --trace --seed 0 lib/some_dir/file_to_watch.ex Re-run only failed tests $ mix test.watch --failed --trace --seed 0 lib/some_dir/file_to_watch.ex Using fswatch, re-run only the test files that have changed as well as the tests that have gone stale due to changes in lib and pause on any failures $ fswatch lib test | mix test --listen-on-stdin --stale --seed 0 --trace --max-failures 1 Generate an html coverage report $ mix coveralls.html Occasionally the test database will need to be reset (e.g. if tests were cancelled partway through) $ MIX_ENV = test mix ecto . reset","ref":"developer.html#running-tests","title":"As a developer - Running Tests","type":"extras"},{"doc":"When making an LTI connection from an LMS such as Canvas, we need an internet accessible FQDN with SSL to properly configure a connection. The service ngrok offers an easy to use command line tool that does just this. Download ngrok and install using their instructions (Create a free account if required) Run ngrok locally to tunnel to phoenix app on port 4000 ngrok http 4000 Access your running webapp using the generated https address (shown in console after Forwarding ). This will be the same address used to configure the LMS LTI connection","ref":"developer.html#tunneling-localhost-connection-for-lti-development","title":"As a developer - Tunneling localhost connection for LTI development","type":"extras"},{"doc":"Torus supports LTI 1.3 integration and leverages the Learning Management System for course delivery. To configure an LTI connection, refer to the Torus LTI 1.3 Manual Configuration .","ref":"developer.html#configuring-an-lti-1-3-connection","title":"As a developer - Configuring an LTI 1.3 Connection","type":"extras"},{"doc":"","ref":"self-hosted.html","title":"self-hosted","type":"extras"},{"doc":"There are many different ways to structure your own production instance of Torus. This guide will outline a simple, single-app server method for getting a production instance of torus up-and-running on a linux environment of your choice. These instructions are geared specifically for and tested on Amazon Linux 2 machine, but should be easily adaptable to other linux distros such as Debian or Ubuntu. If this all seems a bit too technical and you just want to use or try out Torus without maintaining all the infrastructure, check out the Open Learning Initiative's production instance at proton.oli.cmu.edu where you can easily get started by creating an authoring account for free.","ref":"self-hosted.html#with-self-hosting","title":"self-hosted - With self-hosting","type":"extras"},{"doc":"Torus requires a few services that are necessary for it to run, the setup of which however is mostly outside the scope of this guide. The following list outlines these prerequisite services and how they should be configured for Torus: VPS (e.g. AWS, Azure, DigitalOcean, Self-hosted) linux server with SSH access Torus requires NodeJS 15+ to be installed on the deployment machine. If node is not available in the torus path, you can use the NODE_PATH environment variable to configure the path. Releases are built using openssl11-devel for erlang which means that OpenSSL 1.1.1 is required to be installed on the deployment target. sudo yum install openssl11 ` ` ` S3-Compliant bucket (e.g. AWS S3, Backblaze B2, Self-hosted MinIO), public read-accessible Torus will need the Access Key ID and the Secret Access Key for writable access Access: Public , Block all public access: Off Bucket Policy: (replace &lt;bucket_name&gt; with the name of your bucket) { &quot;Version&quot; : &quot;2012-10-17&quot; , &quot;Statement&quot; : [ { &quot;Sid&quot; : &quot;PublicRead&quot; , &quot;Effect&quot; : &quot;Allow&quot; , &quot;Principal&quot; : &quot;*&quot; , &quot;Action&quot; : &quot;s3:GetObject&quot; , &quot;Resource&quot; : &quot;arn:aws:s3:::&lt;bucket_name&gt;/*&quot; } ] } ` ` ` Cross-origin resource sharing (CORS): [ { &quot;AllowedHeaders&quot; : [ &quot;*&quot; ] , &quot;AllowedMethods&quot; : [ &quot;GET&quot; ] , &quot;AllowedOrigins&quot; : [ &quot;*&quot; ] , &quot;ExposeHeaders&quot; : [ ] } ] ` ` ` Postgres 9 or later, network accessible from the VPS/server Torus will need a database db_username and db_password to access the database. The configured user must have database create permissions for initial setup. Alternatively, the database can be manually created and use the Oli.ReleaseTasks.migrate_and_seed() command instead of Oli.ReleaseTasks.setup() in the instructions below.","ref":"self-hosted.html#prerequisites","title":"self-hosted - Prerequisites","type":"extras"},{"doc":"Torus User and Directory Once you have provisioned a linux server, it is recommended you set up a specific user and directory from which to deploy Torus. This guide will assume a user torus and a directory /torus from where the app will be deployed. Configuration Get started by opening an SSH session and configuring Torus env. cd / torus vim oli . env This file will define the necessary configs for torus to run and can also be used to modify various other aspects of the system. Make sure to replace any values in &lt;brackets&gt; below. At a minimum, this file should contain: ## default administrator ADMIN_EMAIL = &lt; admin @example . edu &gt; ADMIN_PASSWORD = &lt; admin password &gt; ## public host name HOST = &lt; torus . example . edu &gt; ## Used to specify which port to expose the http server on, but doesnt affect the public url. ## useful for when you are using a proxy and need to run torus on a specific port without changing the ## public url HTTP_PORT = 80 ## Database url with credentials DATABASE_URL = ecto :/ / &lt; db_username &gt; :&lt; db_password &gt; @postgres / oli ## Email sending EMAIL_FROM_NAME = &quot;OLI Torus&quot; EMAIL_FROM_ADDRESS = &quot;no-reply@example.edu&quot; EMAIL_REPLY_TO = &lt; admin @example . edu &gt; ## Amazon AWS S3 and SES email services AWS_ACCESS_KEY_ID = &lt; your_aws_access_key &gt; AWS_SECRET_ACCESS_KEY = &lt; your_aws_secret_access_key &gt; AWS_REGION = &lt; your_aws_region &gt; ## S3 storage service config used for storing and serving media S3_MEDIA_BUCKET_NAME = &lt; your_s3_media_bucket_name &gt; MEDIA_URL = &lt; your_s3_media_bucket_url . s3 . amazonaws . com &gt; ## Google recaptcha key and secret RECAPTCHA_SITE_KEY = &lt; your_recaptcha_site_key &gt; RECAPTCHA_PRIVATE_KEY = &lt; your_recaptcha_private_key &gt; ## Secret key base ## A random 64 byte string. You can generate one by calling: openssl rand -base64 64 SECRET_KEY_BASE = &lt; your_secret_key_base &gt; ## Live view salt ## A random 64 byte string. You can generate one by calling: openssl rand -base64 64 LIVE_VIEW_SALT = &lt; your_liveview_salt &gt; For more configuration variables, see oli.example.env . Deploying a release Torus releases are built automatically on each new commit to master. These prebuilt releases are created specifically for Amazon Linux 2, but Torus can also be built for any other platform using the Building Releases and Production Deployments guide and continuing at Step 2. Using a Prebuilt Release with Amazon Linux 2 (Recommended) Download a prebuilt release by first identifying the version number and first 7 digits of the release SHA you wish to deploy. These can be found on the releases page on the left side of each release (recommended), or alternatively for unstable bleeding-edge builds the master commit history can be used in combination with whichever version is set in mix.exs for that particular commit. RELEASE_VERSION = 0.18 . 3 RELEASE_SHA = c9d615b # fetch the release package from the official torus builds S3 bucket curl -- fail - L https :/ / oli - torus - releases . s3 . amazonaws . com / oli - $ { RELEASE_VERSION } - $ { RELEASE_SHA } . zip - o oli - $ { RELEASE_VERSION } - $ { RELEASE_SHA } . zip # unzip release unzip oli - * . zip - d oli chmod - R + x . / oli # cleanup release zip rm - rf . / oli - * . zip Import configs set - a ; source . / oli . env Initialize the Database . / oli / bin / oli eval &quot;Oli.ReleaseTasks.setup()&quot; Start Torus . / oli / bin / oli start Command Reference Start . / oli / bin / oli start Stop . / oli / bin / oli stop Daemonize . / oli / bin / oli daemon To learn more about these and other elixir release commands, see https://hexdocs.pm/mix/Mix.Tasks.Release.html Attach to Remote iex Shell This will open a remote iex shell in a running instance . / oli / bin / oli remote You can also execute a single command using rpc . / oli / bin / oli rpc &quot;IO.puts(:hello)&quot; NOTE: Since all Torus modules are available and any public function can be executed, be sure to take care in which functions you call so that you do not put the system into an unstable state. Try to avoid calls that involve the database but if necessary, be sure the function you are calling utilizes transactions in case of failure. See https://hexdocs.pm/mix/Mix.Tasks.Release.html#module-one-off-commands-eval-and-rpc for more information.","ref":"self-hosted.html#initial-setup","title":"self-hosted - Initial Setup","type":"extras"},{"doc":"***IMPORTANT - RUN THIS BEFORE RUNNING ANY TASK*** All of the following tasks require environment configs before running: set - a ; source . / oli . env Initial setup Create, migrate, and seed the database before first run . / oli / bin / oli eval &quot;Oli.ReleaseTasks.setup&quot; Seed the database After a new release is deployed, it is a good idea to run this task to apply any migrations . / oli / bin / oli eval &quot;Oli.ReleaseTasks.seed&quot; Migrate the database After a new release is deployed, it is a good idea to run this task to apply any migrations . / oli / bin / oli eval &quot;Oli.ReleaseTasks.migrate&quot; Rollback a database migration After a new release is deployed, it is a good idea to run this task to apply any migrations . / oli / bin / oli eval &quot;Oli.ReleaseTasks.rollback(:oli, &quot; &lt; migration_version_to_rollback_to &gt; &quot;)&quot; Reset the database ############################################################################################ ## WARNING! The following command will wipe all data in the database. Please use caution! ## ############################################################################################ ## reset the database (requires interactive confirmation) . / oli / bin / oli eval &quot;Oli.ReleaseTasks.reset()&quot; ## reset the database (no interactive confirmation for scripting purposes, you better know what you are doing) . / oli / bin / oli eval &quot;Oli.ReleaseTasks.reset(%{ force: true })&quot; Other public functions defined in lib/oli/release.ex are also available as tasks in this way.","ref":"self-hosted.html#useful-release-tasks","title":"self-hosted - Useful Release Tasks","type":"extras"},{"doc":"It is recommended you run torus behind a load balancer or proxy that supports SSL termination and use that to manage SSL certificates. For convenience, a default certificate is provided by torus for development mode only but it is self-signed and therefore will show browser warnings when used. Torus can either be configured to terminate SSL certificates using SSL_CERT_PATH and SSL_KEY_PATH or can be hosted behind a proxy. The most flexible and straightforward solution is to configure Torus behind a proxy using the HTTP_PORT config set to whichever port you intend to point to from your proxy. You can also setup LetsEncrypt certbot to automatically renew SSL certificates before they expire. For example, with HTTP_PORT=8080 set in oli.env , your HAProxy haproxy.cfg might look something like this: global # SSL options ssl - default - bind - ciphers AES256 + EECDH :AES256 + EDH :! aNULL ; tune . ssl . default - dh - param 4096 defaults mode http timeout connect 5000 ms timeout client 50000 ms timeout server 50000 ms option forwardfor # never fail on address resolution default - server init - addr last , libc , none frontend http bind * : 80 mode http # if this is an ACME request to proof the domain owner, then redirect to certbot server acl is_acme_challenge path_beg - i / . well - known / acme - challenge / redirect scheme https code 301 if ! is_acme_challenge ! { ssl_fc } use_backend letsencrypt if is_acme_challenge frontend https bind * : 443 ssl crt / etc / haproxy / certs / no - sslv3 no - tls - tickets no - tlsv10 no - tlsv11 http - response set - header Strict - Transport - Security &quot;max-age=16000000; includeSubDomains; preload;&quot; acl no_server nbsrv ( www ) lt 1 use_backend maintenance if no_server default_backend www backend letsencrypt server letsencrypt 127.0 . 0.1 : 54321 backend www server www 127.0 . 0.1 : 8080 check http - request add - header X - Forwarded - Proto https if { ssl_fc }","ref":"self-hosted.html#haproxy-configuration-and-ssl-certificates","title":"self-hosted - HAProxy Configuration and SSL Certificates","type":"extras"},{"doc":"If your server has a firewall, be sure to open the necessary tcp ports. If using HAProxy, these will probably be 80/tcp and 443/tcp . If using a load balancer and you have HTTP_PORT configured, then that should be the port you expose.","ref":"self-hosted.html#firewall-configuration","title":"self-hosted - Firewall Configuration","type":"extras"},{"doc":"You may want to configure torus as a systemd service to take full advantage of automatic start on reboot, logging, and other facilities. Here is an example of /etc/systemd/system/torus.service configured as a systemd service [ Unit ] Description = torus [ Service ] ExecStart = / app / oli / bin / oli start ExecStop = / app / oli / bin / oli stop [ Install ] WantedBy = multi - user . target This will also require a duplicate of oli.env config file in /etc/systemd/system/torus.service.d/torusenv.conf in the format: [ Service ] Environment = &quot;HOST=mydomain.example.edu&quot; Environment = &quot;PORT=80&quot;","ref":"self-hosted.html#systemd-and-autostart-on-reboot","title":"self-hosted - Systemd and autostart on reboot","type":"extras"},{"doc":"APM for Ruby, Elixir &amp; Node.js that includes error, performance, host, dashboards, anomalies and uptime monitoring. By default it is disabled and is not required for application to run. However, you can choose to activate AppSignal by adding the following ENV variables: APPSIGNAL_OTP_APP = &quot;oli&quot; APPSIGNAL_PUSH_API_KEY = &quot;your-push-api-key&quot; APPSIGNAL_APP_NAME = &quot;Torus&quot; APPSIGNAL_APP_ENV = &quot;prod&quot;","ref":"self-hosted.html#appsignal","title":"self-hosted - AppSignal","type":"extras"},{"doc":"This document outlines the rules and guidelines for client-side code development in Torus. Client-side code here refers to any code written by Torus developers that runs client-side in the browser. This includes complete standalone React applications and small snippets of code that run in the context of a server-rendered page. Each item here is categorized as either a rule (required) or a guideline (recommended but not absolutely required). Guidelines recognize that there are always unique circumstances where it makes sense to depart from the recommendation. Rules will include words like must and always and guidelines include words like should and can .","ref":"client-coding.html","title":"Client-side coding standard","type":"extras"},{"doc":"All client-side code must be written in Typescript as opposed to being written directly in JavaScript. All code must be formatted using Prettier and pass ESLint checks. A GitHub build step will fail for any PR that includes code that triggers an ESLint error. Types Developers should leverage the TypeScript type system to model the domain as much as possible. This includes using type aliases, union and intersection types, discriminated union types, and utility types ( Partial&lt;Type&gt; , Readonly&lt;Type&gt; , etc). Developers should add TypeScript type annotations to all new code. Developers should use the TypeScript type construct over an interface for all cases except for when extensibility is needed. For example, a type cannot be used in the following: interface Identifiable { id: string; } export interface Paragraph extends Identifiable { type: &quot;p&quot;; } Async code Async code should be written using standard ES6 Promise support or async/await features. Functional programming Code should be written in a functional programming style, leveraging first-class functions, programming as transformation, immutability, pure functions, etc. Immutability Code should be written leveraging immutable data structures and techniques as must as possible, this is particular importance in React-based UI code. Legacy Echo code that ports existing Immutable.js code can stay as-is, but new code that needs immutable data structures should be written using Immer.js. Developers can use the Object.assign({}, current, update) pattern as well. Programming as transformation For conciseness and readability, Code should make heavy use of map and reduce style data transformations instead of imperative loops and similar constructs. For example: return Object.keys(textEntity) .filter((attr) =&gt; textEntity[attr] === true) .map((attr) =&gt; supportedMarkTags[attr]) .filter((mark) =&gt; mark) .reduce((acc, mark) =&gt; `&lt;${mark}&gt;${acc}&lt;/${mark}&gt;`, text);","ref":"client-coding.html#core-language","title":"Client-side coding standard - Core language","type":"extras"},{"doc":"Library/framework User interfaces must be built using React. Developers should seek first to implement a React component as a functional stateless component. State, if needed, should be added via useState or useReducer hooks. Side effects should be incorporated via useEffect . For more complicated use cases it is acceptable to fall back to a traditional, class-based React component. State management Developers should strive to use the simplest approach possible for global state management. The simplest approach being not using any third-party state management library and instead just maintaining all top-level state in a component (via useReducer or one or more useState hooks) and passing it down through properties. This approach only scales so far, thus for more complicated applications developers should fall back to a third-party library for global state management. Our team's experience with Redux overall has been positive, but we recognize that there is a substantial amount of boilerplate in a type-safe Redux implementation. Given that Torus client tends to have smaller, more focused apps we are seeking lighter-weight Redux alternatives including useReducer and up and coming new libraries such as https://recoiljs.org/ Styling Components should leverage Bootstrap 4 and be written in a way that works with the Torus theming approach. TODO add more details here, but a main takeaway is that any custom CSS should be captured in a .scss definition file.","ref":"client-coding.html#ui","title":"Client-side coding standard - UI","type":"extras"},{"doc":"Code should be unit tested using the existing jest based unit testing infrastructure. UI code should be structured in a way that allows the implementation of the logic to be decoupled from the UI implementation, so that this logic can be easily unit tested.","ref":"client-coding.html#testing","title":"Client-side coding standard - Testing","type":"extras"},{"doc":"","ref":"server-coding.html","title":"Server-side coding standard","type":"extras"},{"doc":"This project uses the default Elixir code formatting rules through running mix format . To enable auto-format on save, install the ElixirLS plugin for your code editor and add a configuration option. For Visual Studio Code, you can do this by opening the config file with cmd+p , typing &gt; Open Settings , and adding this line: &quot;editor.formatOnSave&quot;: true","ref":"server-coding.html#code-formatting","title":"Server-side coding standard - Code Formatting","type":"extras"},{"doc":"User interface code can be implemented using either traditional, stateless controller rendered templated views or with stateful Phoenix LiveView implementations. For Phoenix LiveView implemented user interfaces, all new views and components should be implemented using the Surface library.","ref":"server-coding.html#ui-code","title":"Server-side coding standard - UI Code","type":"extras"},{"doc":"Fill out the template below as the body of your pull request. Any pull request that does not include enough information to be reviewed in a timely manner may be closed at the maintainers' discretion. The pull request must update the test suite to demonstrate the changed functionality. After you create the pull request, all status checks must be pass before a maintainer reviews your contribution.","ref":"pr-template.html","title":"Pull Request Template","type":"extras"},{"doc":"Link to the issue describing the bug that you're fixing or the enhancement that you are implemening. If there is not yet an issue that your work targets, please open a new issue and then link to that issue in your pull request. Note: In some cases, one person's &quot;bug&quot; is another person's &quot;feature.&quot; If the pull request does not address an existing issue with the &quot;bug&quot; label, the maintainers have the final say on whether the current behavior is a bug.","ref":"pr-template.html#identify-the-issue","title":"Pull Request Template - Identify the Issue","type":"extras"},{"doc":"We must be able to understand the design of your change from this description. If we can't get a good idea of what the code will be doing from the description here, the pull request may be closed at the maintainers' discretion. Keep in mind that the maintainer reviewing this PR may not be familiar with or have worked with the code here recently, so please walk us through the concepts.","ref":"pr-template.html#description-of-the-change","title":"Pull Request Template - Description of the Change","type":"extras"},{"doc":"Explain what other alternates were considered and why the proposed version was selected","ref":"pr-template.html#alternate-designs","title":"Pull Request Template - Alternate Designs","type":"extras"},{"doc":"What are the possible side-effects or negative impacts of the code change?","ref":"pr-template.html#possible-drawbacks","title":"Pull Request Template - Possible Drawbacks","type":"extras"},{"doc":"What process did you follow to verify that the change has not introduced any regressions? Describe the actions you performed (including buttons you clicked, text you typed, commands you ran, etc.), and describe the results you observed.","ref":"pr-template.html#verification-process","title":"Pull Request Template - Verification Process","type":"extras"},{"doc":"","ref":"changelog-pr.html","title":"Changelog processes","type":"extras"},{"doc":"Developer performs feature work or bug fix on a branch off of master . Developer opens a pull request against master once the work is completed. The PR should include a change to CHANGELOG.md summarizing the work. Reviewer reviews the PR and either requests changes or approves. After approval, the reviewer squashes and merges to master, updating the commit message to summarize the entirety of the work item. This aggregate commit message must be prefixed with the change type, a description, and a reference to the pull request number. For example, [BUG FIX] A description #123 CMU-30 or [FEATURE] Another description #231 CMU-30 . It should also include a reference to the Argos JIRA ticket number. Valid Change Types [FEATURE] : New feature for the user [BUG FIX] : Bug fix for an existing feature [DOCS] : Changes purely to documentation [REFACTOR] : Refactoring of code, no changes in functionality [CHORE] : Updating of build infrastructure, deployment automation, etc. [PERF] : Changes that target a performance improvement [ENHANCEMENT] : Small improvements to existing features","ref":"changelog-pr.html#feature-development-bug-fixing","title":"Changelog processes - Feature development / bug fixing","type":"extras"},{"doc":"Developer opens a PR against master to update the version in mix.exs and to update the release date within CHANGELOG.md . PR lands to master with a commit message of [RELEASE] x.y.z with the appropriate version number. A Github Release is created with the Tag version and Release title formatted as vx.y.z (e.g. v1.0.0 ) and the corresponding list of Enhancements and Features as well as any other relevant information for the release copied from CHANGELOG.md into the description. A PR is opened to merge master to test , after it builds and merged any required testing is done on tokamak.oli.cmu.edu A PR is opened to merge master to prod . After it builds it is merged to trigger the deployment to production.","ref":"changelog-pr.html#release","title":"Changelog processes - Release","type":"extras"},{"doc":"The following is an example of what the above guidelines yield in the commit history on master : [ RELEASE ] v0 . 4.1 [ BUG FIX ] Restored ability to sort media items by size #324 [ BUG FIX ] Corrected position of image thumbnails within media library #345 [ FEATURE ] Added new Ordering activity type #346","ref":"changelog-pr.html#examples","title":"Changelog processes - Examples","type":"extras"},{"doc":"","ref":"deployment.html","title":"CI/CD and Deployment Process","type":"extras"},{"doc":"Torus uses Github Actions for its CI/CD pipelines. When a PR is opened, a build is automatically started and several checks are run including unit tests and lint checks which must all pass before a PR can be merged. Once a branch is merged into master, the resulting commit is packaged and deployed to the test server ( tokamak.oli.cmu.edu ). The test server will always represent the latest from master unless a manual deployment is made. When a release is made (tagged vX.Y.Z), a deployment is kicked off to the production server ( proton.oli.cmu.edu ). A production deployment will always use a prebuilt artifact identified by the version and commit SHA to ensure that the release tested is the same as the release deployed. Test Server: tokamak.oli.cmu.edu Production Server: proton.oli.cmu.edu","ref":"deployment.html#overview","title":"CI/CD and Deployment Process - Overview","type":"extras"},{"doc":"Every pull request is required to pass a set of status checks in both Elixir and Typescript including a successful build, all unit tests passing, and successful lint with no errors (TypeScript). These checks are automatically started when a pull request is created. Other automated checks include Coveralls for unit test coverage and GitGuardian for identifying accidentally leaked secrets, however these checks are only informative and discretion is left to the developer and code reviewer to decide if issues found are blocking.","ref":"deployment.html#pull-requests","title":"CI/CD and Deployment Process - Pull Requests","type":"extras"},{"doc":"Deployments to the test server are automatically initiated when a pull request is landed to master. This means the test server will usually be up-to-date with the latest changes from the master branch. There are some situations however, when someone may want to manually push a deployment to the test server which can be accomplished with the following: Release Candidates If a release candidate is created with a tag formatted as vX.Y.Z-rcN where X.Y.Z represents a version number and N is the release candidate number, a deployment of the tag's targeted ref will be deployed to the test server. Go to https://github.com/Simon-Initiative/oli-torus/releases and click &quot;Draft a new release&quot; Enter your vX.Y.X-rcN for Tag version and Release Title Add the Features and Bug Fixes sections (formatted as markdown) to the description Check &quot;This is a pre-release&quot; Click &quot;Publish release&quot; deploy-test Tag A deployment can be initiated by tagging any git ref with the deploy-test tag and pushing to remote. For example: git tag -- delete deploy - test # if the tag previously existed locally git tag deploy - test git push origin deploy - test -- force","ref":"deployment.html#deployments-to-test","title":"CI/CD and Deployment Process - Deployments to Test","type":"extras"},{"doc":"Deployments to the production server will be initiated when a release is created with the tag formatted as vX.Y.Z where X.Y.Z represents a version number. Note: Production deployments assume a previous build has been packaged, and therefore any commit tagged as a release must exist on the master branch, a hotfix-* branch or be packaged by tagging the commit with the package tag first.","ref":"deployment.html#deployments-to-production","title":"CI/CD and Deployment Process - Deployments to Production","type":"extras"},{"doc":"A hotfix branch can be created using the release tag you wish to branch from. For example: git checkout - b hotfix - X.Y . [ Z + 1 ] vX . Y.Z git push origin hotfix - X.Y . [ Z + 1 ] Once the hotfix branch is created, it will essentially act as the master branch to land all bug fixes and enhancements that are intended to be included in the hotfix. When a hotfix branch is ready to be deployed, it can be tagged using the Release Candidate and Deployment Process outlined above. Hotfix branches that follow the convention hotfix- will automatically be packaged when pushed to remote, just like master. Make sure to wait for the package step to complete before creating a release, or else the deployment will fail. Note: Because hotfix branches are automatically packaged based on the branch name convention, there is no need to manually tag with package before deploying. Finally, make sure the hotfix branch is eventually merged back to master to be included in downstream development. To do this easily, create a new branch from the hotfix branch called integrate-X.Y.Z (the name here is not necessarily important, but just serves as an example). Then pull master into this integration branch. Once any/all merge conflicts are resolved, open a PR against master.","ref":"deployment.html#hotfixes","title":"CI/CD and Deployment Process - Hotfixes","type":"extras"},{"doc":"","ref":"building.html","title":"Production Deployments","type":"extras"},{"doc":"Torus releases are built automatically with each new commit to master and uploaded to the public S3 bucket oli-torus-releases . These prebuilt releases are created specifically for Amazon Linux 2, but Torus can also be built for any other platform using the Building a Release guide below. To download a prebuilt release, start by first identifying the version number and first 7 digits of the release SHA you wish to deploy. These can be found on the releases page on the left side of each release (recommended), or alternatively for unstable bleeding-edge builds the master commit history can be used in combination with whichever version is set in mix.exs for that particular commit. RELEASE_VERSION = 0.18 . 3 RELEASE_SHA = c9d615b # fetch the release package from the official torus builds S3 bucket curl -- fail - L https :/ / oli - torus - releases . s3 . amazonaws . com / oli - $ { RELEASE_VERSION } - $ { RELEASE_SHA } . zip - o oli - $ { RELEASE_VERSION } - $ { RELEASE_SHA } . zip","ref":"building.html#using-a-prebuilt-release-recommended","title":"Production Deployments - Using a Prebuilt Release (Recommended)","type":"extras"},{"doc":"Torus recommends using elixir releases for production deployments. You will have to have Elixir installed on your machine to build Torus. A release can be created by executing the following script in the oli-torus repository with a current git commit SHA set to RELEASE_SHA . This will compile a release for the system architecture on which it is executed: # clone the oli-torus repository cd / tmp git clone https :/ / github . com / Simon - Initiative / oli - torus . git cd oli - torus # setup asset build dependencies npm install - g yarn yarn -- cwd . / assets RELEASE_SHA = $ ( git rev - parse -- short HEAD ) sh . github / actions / torus - builder / entrypoint . sh You'll find the newly built release under _build/prod/rel/oli . This can be zipped and deployed however you see fit (e.g. sftp, S3 and curl, etc.). cd _build / prod / rel / oli zip - r . . / . . / . . / . . / oli - $ { RELEASE_SHA } . zip * The release will contain all the necessary binaries to run Torus including the Erlang RunTime System and the BEAM virtual machine (except for NodeJS, which is expected to be installed on the target and available in the torus user's PATH ). For more information on setting up a production environment, refer to the Setting Up a Production Server guide. Once a release has been created and deployed to the target machine where you intend to run it, you can execute predefined release commands to start/stop/daemonize the app. To perform any of these though, you must first source the oli.env configuration into the current shell to configure the environment. Configure Environment ( REQUIRED before running any eval or iex commands) set - a ; source . / oli . env Stop the server . / oli / bin / oli stop Prepare the release # remove old deployment, if one exists rm - rf . / oli / unzip oli - * . zip - d oli chmod - R + x . / oli # cleanup release zip rm - rf . / oli - * . zip Migrate and Seed Database . / oli / bin / oli eval &quot;Oli.ReleaseTasks.migrate_and_seed&quot; Restart the server . / oli / bin / oli daemon","ref":"building.html#building-a-release","title":"Production Deployments - Building a Release","type":"extras"},{"doc":"If you see the following deps build error, you must install OpenSSL 1.1 in order for AppSignal to compile and work properly. == &gt; appsignal Downloading agent release AppSignal installation failed : Could not download archive from any of our mirrors . Please make sure your network allows access to any of these mirrors . Attempted to download the archive from the following urls : - URL : https :/ / appsignal - agent - releases . global . ssl . fastly . net / 7376537 / appsignal - x86_64 - linux - all - static . tar . gz - Error ( hackney response ) : { :error , { :options , { :insufficient_crypto_support , { :&quot;tlsv1.3&quot; , { :versions , [ :&quot;tlsv1.3&quot; , :&quot;tlsv1.2&quot; ] } } } } } - URL : https :/ / d135dj0rjqvssy . cloudfront . net / 7376537 / appsignal - x86_64 - linux - all - static . tar . gz - Error ( hackney response ) : { :error , { :options , { :insufficient_crypto_support , { :&quot;tlsv1.3&quot; , { :versions , [ :&quot;tlsv1.3&quot; , :&quot;tlsv1.2&quot; ] } } } } }","ref":"building.html#notes","title":"Production Deployments - NOTES","type":"extras"},{"doc":"Torus is a learning engineering platform for authoring, delivering and improving online courses.","ref":"introduction.html","title":"Introduction","type":"extras"},{"doc":"Automated Course Project Lifecyle Authors can make edits and &quot;push a button&quot; to have those edits made available to end users Tight LMS Integration Torus is accessible from any LTI 1.3 compliant LMSes, and Torus defers to those LMSes roster management, gradebook and other functionality Run-time extensibility The system can have new content types and learning activities added to it at run-time by third party developers Simon Ecosystem Integration Torus will enable deep integrations with existing and future Simon Ecosystem projects Learning Engineering Centric UX Learning engineering science and best practies embedded in the UI/UX guide users through effective course creation","ref":"introduction.html#key-features","title":"Introduction - Key Features","type":"extras"},{"doc":"The following are the key non-functional requirements and considerations that fuel Torus technology and design choices: Usability Torus must be understandable and approachable by new users, especially those unfamiliar with learning engineering concepts Extensibility - Several aspects of the system are designed to be extended. The main focus of system extensibility is to support the development of new student-facing learning activities. Interoperability - Torus is designed to interoperate seemlessly with external systems such as Learning Management Systems, using relevant industry standards Scalability Torus must scale to 10x to 100x the user load of the current OLI system, which at peak usage levels sees around 1,000 reqs/min","ref":"introduction.html#key-design-and-technical-considerations","title":"Introduction - Key Design and Technical Considerations","type":"extras"},{"doc":"Elixir/Phoenix All server side code in Torus is implemented in Elixir using the Phoenix web application framework. Torus also powers client-side UIs with Elixir code via Phoenix LiveView. TypeScript/React The limited amount of pure client-side code in Torus is written in TypeScript and utilises React for UI.","ref":"introduction.html#technology-stack-overview","title":"Introduction - Technology Stack Overview","type":"extras"},{"doc":"Primary data storage uses Postgres RDBMS.","ref":"introduction.html#postgres","title":"Introduction - Postgres","type":"extras"},{"doc":"Torus is implemented in an architecture that resembles that of a traditional monolithic web-based application. There is a single application server that handles end user requests from web browser clients through a layered set of services that ultimately access the persistence layer. A diagram of this architecture at a conceptual level is as follows: Torus is designed to take advantage of Phoenix clustering support and Distributed Erlang to meet scalability and performance requirements. The various &quot;Applications&quot; that comprise Torus can be replicated across and run on any number of Erlang nodes that are part of the cluster. This allows Torus to mimic modern, scalable service based architectures by varying its deployed configuration.","ref":"introduction.html#architectural-overview","title":"Introduction - Architectural Overview","type":"extras"},{"doc":"This page outlines fundamental system design choices","ref":"high-level.html","title":"High-level design","type":"extras"},{"doc":"System roles are divided into two categories. A user can be represented by a single role in each category. Authoring Role Description Author Someone who owns and/or contributes to the creation of course content Administrator Someone who is in charge of administering the entire system. Administrators have complete access to all content and administrative tools. Delivery Role Description Student Someone who has accessed the system from an LMS as a student. Students have the ability to view course content, complete coursework and earn assignment grades. Instructor Someone who has accessed the system from an LMS as an instructor. Instructors can create/edit a course section and modify content for that section. Administrator Someone who has accessed the system from an LMS as an administrator. Administrators have all the same capabilities as instructors as well as the ability change institution-wide settings such as LTI integration or policies.","ref":"high-level.html#roles","title":"High-level design - Roles","type":"extras"},{"doc":"Resource A resource is an organized collection of content that is versioned and tracks content changes over time. Resources have a globally unique identifier across projects so that even if their content has diverged (different HEAD revision), they have the ability to diff and merge content with the same resource in other projects. Content within the system that is intended to track/diff/merge changes over time and provide rich versioning support is most likely using a resource to do this. Some examples of resource types are Page, Assessment, Activity, Learning Objective, etc... Resource Revision A resource revision represents a resource at a specific moment in it's revision history. A revision points to it's parent revision and therefore links to all of it's previous ancestors. The latest revision for a resource is referred to as the HEAD revision and it is referenced by the resource as it's last revision. If a revision's parent is null, then it is the initial revision of a resource. Revisions also track a resource's slug which is described in another section below. -- -- -- -- -- -- - HEAD INITIAL | Resource | -&gt; Revision -&gt; Revision -&gt; Revision -&gt; Revision -- -- -- -- -- -- - Project A project is an organized container of all the resources that comprise a course and it's curriculum. These resources include pages, assessments, learning objectives, and media. Publication A publication is a snapshot of a project at some point in time. Publications serve as an update, version or milestone of a project that an author deems ready for production use. Publications are created when a package is published which then become available for instructors to use for creating or updating a course section. Section A section is an instance of a course publication that is configured by an instructor and delivered to students. A new section will be created for each LMS context or cohort of students intended to access course content. A section tracks learner progress and reports grades back to the connected LMS.","ref":"high-level.html#system-ontology","title":"High-level design - System Ontology","type":"extras"},{"doc":"When a resource is created, a slug will be generated based on some semantic meaning for the resource (e.g. using the resource title). This slug is actually stored at the revision level because it can change over time as the resource changes. For example, if a resource with title &quot;Introduction to Linear Algebra&quot; is created, then it's slug might be introduction-linear-algebra-55jl2k. As changes are made to the content, but not the title, this slug may remain the same for each new revision that gets created. If at some point the title is changed to &quot;Basic Linear Algebra Concepts&quot;, the slug might change to basic-linear-algebra-conc-w8s25t. This slug is now related to the new semantic meaning of it's resource at that revision. It's important to understand however, that even though there are two different slugs for multiple different revisions, they are really just identifiers for the parent resource and both can be used to find a specific resource. To summarize, a slug is a resource identifier that is stored at the revision level. Slugs do not have to change across revisions, but they can. Multiple slugs can point to a single resource.","ref":"high-level.html#resource-slug","title":"High-level design - Resource Slug","type":"extras"},{"doc":"","ref":"publication-model.html","title":"Publication Model","type":"extras"},{"doc":"Torus employs a publication model that is designed to support: The ability to allow forward development for an author without interferring with student and instructor visible content The ability to track changes across revisions of a project resource The ability to migrate changes for resources across different projects The ability to allow instructors to preview and opt-in to using newly published content","ref":"publication-model.html#overview","title":"Publication Model - Overview","type":"extras"},{"doc":"The primary components and their relationships are as follows: A Resource in a course project can be a page (graded or ungraded), container (e.g. Unit, Module), an activity, or learning objective. A course project consists of a collection of resources. This relationship is a many-to-many relationship to allow multiple course projects to share the same resource. That is a key aspect of Torus design to allow families of related course projects to exist in which content and changes of a shared resource can migrate from course to course within the course project family. Changes in the content of any particular resource, over time, are modeled as a collection of Revisions , hence the one-to-many relationship from Resource to Revision . A course project has a series of Publications . A publication is either published (meaning it is available and visible to instructors to use) or it is unpublished . Course Sections that an instructor teaches reference exactly one Publication for the course projects that the section is using. Finally, at the heart of the publication model, the Published Resource exists to tie together a specific revision for every resource in a course for a specific publication.","ref":"publication-model.html#data-model","title":"Publication Model - Data Model","type":"extras"},{"doc":"As an example of this publication model, consider the following table of Published Resource records, all from one course project that consists of two resources identified by R1 and R2 that have revision records identified by V1 and V2 , respectively. Initially the course has one publication identified by P1 so the published resource records look like: Publication Resource Revision P1 R1 V1 P1 R2 V2 The course author makes a change to the R2 resource and publishes that change as a second publication P2 . Now the published resource records look like: Publication Resource Revision P1 R1 V1 P1 R2 V2 P2 R1 V1 P2 R2 V3 In the above, we see how the original publication is preserved - so any course sections teaching it will have their content unaffected by the new publication. Any course section that opts-in to using the P2 publication will see the update to the R2 resource.","ref":"publication-model.html#example-data","title":"Publication Model - Example Data","type":"extras"},{"doc":"Torus attempts track student interaction and results for pages, activities and parts of activities.","ref":"attempt.html","title":"Attempt design","type":"extras"},{"doc":"Torus models attempts in a hierarchy that mirrors the hierarchical structure of course content. So for every page that a student visits in Torus a page attempt record is created. For every activity that exists on a visited page, an activity attempt record is created (which points back to the parent page attempt record). Finally, for every part that an activity defines, a part attempt record is created. The entire attempt hierarchy is rooted in a resource access record that tracks, amongst other things, the rolled up student result (aka grade) across all attempts.","ref":"attempt.html#attempt-hierarchy","title":"Attempt design - Attempt Hierarchy","type":"extras"},{"doc":"The Torus attempt hierarchy supports preservation of historical attempts. Consider an example where a student takes a graded assessment (i.e. a page) that contains two activities (each with one part) twice. The full attempt hierarchy, with history, would look like the following: Resource Access -- Page Attempt 1 -- -- Activity A , Attempt 1 -- -- -- Part 1 , Attempt 1 -- -- Activity B , Attempt 1 -- -- -- Part 1 , Attempt 1 -- Page Attempt 2 -- -- Activity A , Attempt 1 -- -- -- Part 1 , Attempt 1 -- -- Activity B , Attempt 1 -- -- -- Part 1 , Attempt 1 As another example, consider an ungraded page that contains one activity that a student attempts several times: Resource Access -- Page Attempt 1 -- -- Activity A , Attempt 1 -- -- -- Part 1 , Attempt 1 -- -- Activity A , Attempt 2 -- -- -- Part 1 , Attempt 1 -- -- Activity A , Attempt 3 -- -- -- Part 1 , Attempt 1 -- -- Activity A , Attempt 4 -- -- -- Part 1 , Attempt 1","ref":"attempt.html#attempt-history","title":"Attempt design - Attempt History","type":"extras"},{"doc":"Attempts can exist in multiple states. These states are: Non-existent : The student has yet to access the page, thus no attempt exists. Active : A student attempt is &quot;active&quot; when they are currently interacting with this page or activity therefore the attempt is &quot;active&quot;. Submitted : The student submitted a response for an activity that requires manual instructor scoring, thus the attempt enters a &quot;submitted&quot; state. The attempt is now read-only for the student. Evaluated : The student response has been evaluated (whether automatically or manually) and a score has been recorded into the attempt record. The attempt is now read-only for both the instructor and student.","ref":"attempt.html#attempt-states","title":"Attempt design - Attempt States","type":"extras"},{"doc":"When the underlying page or activity has a new revision available due to the instructor applying a new course project publication, Torus handles existing page and activity attempts in different ways depending on the attempt state.","ref":"attempt-handling.html","title":"Attempt handling","type":"extras"},{"doc":"Here is how updates to content are applied to attempts in ungraded pages: Evaluated or Submitted : Evaluated and submitted attempts are affected in no way by new revision publication. These attempts always maintain a reference to the revision of the page or the activity that existed at the time of submission or evaluation. If a student &quot;Resets&quot; an evaluated attempt to create another attempt, this new attempt will always show the content of the most recentl published revision. Active : Active activity attempts are left as-is by the system until the time that the student accesses the page again. In this manner, a student that is in the middle of interacting with a page that contains activities will not have this content updated by new revision publication. It is only at the time that a student revisits a page that has an active attempt where Torus will detect that a new revision of the page or activity is available. There are two cases to consider here: The page itself has a new revision available. In this case, Torus simply creates a new page attempt record with all new activity attempt records for the student. The reasoning here is that since actual page content itself has changed the system should give all new activity attempts to allow the student to see these activities in the context of the latest page content. Only activity revisions have changed. In this case, a new activity attempt will be created for each of only the changed activities. No new page attempt is created. Non existent : For pages that a student has never visited, there is of course no attempt hierarchy present. At the time of first visit, the student will always encounter the latest published revision for the page and activities.","ref":"attempt-handling.html#ungraded-pages","title":"Attempt handling - Ungraded Pages","type":"extras"},{"doc":"Evaluated or Submitted : Both evaluated and submitted attempts for graded pages are affected in no way by new revision publication. Similar to ungraded page attempts, these attempts always maintain a reference to the revision of the page or the activity that existed at the time of finalization. Active : Active activity attempts are left as-is by the system. In this manner, a student that is in the middle of interacting with a graded page will not have the content that they see updated by new revision publication. Even if the student leaves the page, and then returns, they will continue to see their attempt that is pinned to the original content. After the student submits the entire assessment for evaluation, subsequent attempts will show the newly published content. Non existent : For graded pages that a student has never visited, there is of course no attempt hierarchy present. At the time of first visit, the student will always encounter the latest published revision for the page and activities.","ref":"attempt-handling.html#graded-pages","title":"Attempt handling - Graded Pages","type":"extras"},{"doc":"Torus authoring is designed to support only one user editing a document at a time. To enforce this, the system requires than an exclusive write-lock be obtained prior to editing a document. The Torus authoring framework implementation handles obtaining and releasing the write-lock for a set of documents. This implicit locking approach, as opposed to an explicit approach, simplifies an activity implementation since the activity implementation does not need to concern itself with obtaining and releasing locks. The following sequence diagram overviews the locking implementation. The important takeaways from the above diagram are: The Torus framework for authoring takes care of obtaining and releasing document locks An activity implementation can strictly rely on the editMode property given to it to determine whether it should enable or disable authoring","ref":"locking.html","title":"Document locking","type":"extras"},{"doc":"Page model is governed by a JSON schema.","ref":"page-model.html","title":"Page model","type":"extras"},{"doc":"","ref":"gdpr.html","title":"GDPR compliance","type":"extras"},{"doc":"Receive users’ consent before you use any cookies except strictly necessary cookies. Provide accurate and specific information about the data each cookie tracks and its purpose in plain language before consent is received. Document and store consent received from users. Allow users to access your service even if they refuse to allow the use of certain cookies Make it as easy for users to withdraw their consent as it was for them to give their consent in the first place. The Cookie Law does not require that records of consent be kept but instead, indicates that you should be able to prove that consent occurred — even if that consent has been withdrawn. To comply with the requirements, our approach needed to ensure that an opportunity for the user to provide consent is presented even in cases where a user never logins into our system. That consideration, combined with not having to maintain records of consent, meant that an approach that makes use of long-lived cookies to keep track of consent works fine in our use case. The approach works as follows. Each page on our site is instrumented with some cookie consent management scripts The scripts run every time any page is loaded on the browser The script first checks to see if a cookie with the name “_cky_opt_in” is present and that its value is “true”. This cookie is used to track whether the consent pop-up has been launched in that particular browser before. If not a new one is created with a value “false” and an expiration value of 365 days (Compliant with GDPR). A cookie named “_cky_opt_in_dismiss” with a duration of 1hr is also created whenever the cookie above is created. This cookie allows our website to re-prompt the user with the cookie consent pop-up every hour if they simply dismissed the pop-up without providing consent If the user agrees to allow cookies, a cookie named “_cky_opt_choices” is created. Its duration is 365 days and the value is the consent preferences agreed to by the user. The value of the cookie “_cky_opt_in” is updated to true. Note that after 365 days, our system will prompt the user for a new consent The cookie consent pop-up also presents the user with the option to modifly cookie preferences. The preferences dialog simply updates the values store in the “_cky_opt_choices” cookie or creates one if one is not already present. Each page on our site has a footer containing a link that will directly launch the preferences dialog any time the user wishes to adjust their cookie preferences.","ref":"gdpr.html#cookie-compliance-requirements","title":"GDPR compliance - Cookie compliance requirements","type":"extras"},{"doc":"","ref":"misc.html","title":"Miscelleanous","type":"extras"},{"doc":"bcrypt_elixir requires &gt;1 CPU core to function. If you have only one core, on say a small VPS, your release will crash without giving a useful error message!! For a single core host, use Pbkdf2 instead of Bcrypt. See here for more on this: https://github.com/riverrun/comeonin/wiki/Deployment Link account using social login will not work out of the box in development mode! This is because you must configure an exact url with the OAuth provider, and therefore a local ngrok tunnel address will not work. If you really need this to work, you can configure your OAuth provider with your temporary ngrok address e.g. https://163400959f6a.ngrok.io/auth/google/link/callback . Be sure to also set your HOST in oli.env to your ngrok address as well (e.g. HOST=https://163400959f6a.ngrok.io ) or else you will be redirected to localhost by default after login and the user session will not be present for linking, because it was stored in the session for the ngrok address. Because of this complexity, it is recommended to simply use an email account to link accounts, which does not experience this issue.","ref":"misc.html#general-notes","title":"Miscelleanous - General Notes","type":"extras"},{"doc":"When the system generates email in production, generally it will be handed to an email service such as Amazon SES. Any email service supported by Bamboo can be configured in config/prod.exs. Refer to the Bamboo and Pow docs to see a list of all supported email adapters and how to configure them https://hexdocs.pm/pow/configuring_mailer.html#content , https://hexdocs.pm/bamboo/readme.html In development mode, the system will use the Bamboo.LocalAdapter mailer, which stores sent mail in memory and is accessible via web browser at https://localhost/dev/sent_emails . There is also a specific test adapter configured for unit testing.","ref":"misc.html#access-generated-emails-in-development","title":"Miscelleanous - Access Generated Emails in Development","type":"extras"},{"doc":"To ease the burden of creating a new registration after every database reset, there is the option to automatically create LTI registrations attached to the default institution in dev environment by creating a registrations.json file in the project root. Example: [ { &quot;issuer&quot; : &quot;https://canvas.oli.cmu.edu&quot; , &quot;client_id&quot; : &quot;XXXXXXXXXXXXX&quot; , &quot;key_set_url&quot; : &quot;https://canvas.oli.cmu.edu/api/lti/security/jwks&quot; , &quot;auth_token_url&quot; : &quot;https://canvas.oli.cmu.edu/login/oauth2/token&quot; , &quot;auth_login_url&quot; : &quot;https://canvas.oli.cmu.edu/api/lti/authorize_redirect&quot; , &quot;auth_server&quot; : &quot;https://canvas.oli.cmu.edu&quot; } ] With this file, now when you run mix ecto.seed or mix ecto.reset , a registration with these details will be created for you.","ref":"misc.html#create-registrations-from-seed","title":"Miscelleanous - Create Registrations from seed","type":"extras"},{"doc":"","ref":"overview.html","title":"Overview","type":"extras"},{"doc":"Torus operates broadly in two different modes: Authoring : Authoring mode is a set of features used by authors to create, update and publish the material within their course project. Delivery : Delivery mode is a set of features used by Instructors and Students during the delivery of course material to students in a course section. The material with course projects is modeled as a collection of Resources of different supported resource types. The following lists the various types of resources that exist: Container : A collection of pages or containers that can correspond to &quot;Units&quot; or &quot;Modules&quot; within a course. Page : A collection of content and activities that offer student instruction and assessment. Pages can be either &quot;graded&quot; or &quot;practice&quot;. Activity : A scorable interaction used in both practice or assessment contexts. Objective : A learning objective that course content attempts to instruct and that activities offer practice and assessment on. Tag : A tag is a flexible mechanism that can power a variety of platform functionality such as activity bank selection. Activities have several important concepts: Activity type : Torus supports a variety of different kinds of student interactive experiences such as multiple choice, ordering, and check all that apply. Activity instance : An activity instance is created when an author defines (aka &quot;authors&quot;) a new activity of a supported activity type. Activity reference : Activity instances are not directly embedded into pages, rather a reference to an instance is stored within pages. This mechanism allows activity instances to be shared across pages. Activity bank : A collection of activity instances that can be randomly selected according to a defined set of criteria at delivery time. A page can contain activity bank selections which allows the system to select and render different activities for each different student attempt. Parts : Activity instances have a collection of one or more parts . A part offers a mechanism to track student interaction and submission, and ultimately to store a system or instructor assign score. Some activity types have a fixed number of parts: for example a multiple choice activity has only one part which models which choice the student selected, their received score and any received feedback. Other activity types feature multiple parts, and in some cases the number of parts is dynamic and determined at the time that the author defines the activity instance. For example, an author can create a &quot;Multi input&quot; activity that features three &quot;fill in the blank&quot; text inputs in the middle of the question stem. This activity instance would have three parts, one for each of these inputs, and allows each of them to be scored individually. Grading approach : Each part within an activity instance can specify its required grading, or scoring, approach. The supported options are automatic and manual . Automatically scored parts require the definition of a collection of responses that specify the rules to use to allow the sytem to perform automatic scoring. Manually scored parts for activities ultimately require the instructor to review the submission for the part and to assign a score and provide feedback.","ref":"overview.html#important-concepts-and-terms","title":"Overview - Important concepts and terms","type":"extras"},{"doc":"","ref":"implementing.html","title":"LTI 1.3","type":"extras"},{"doc":"This is a summary of the LTI 1.3 handshake outlined in the IMS Security Framework 1.0 Specification ( 5.1 Platform-Originating Messages ) geared toward elixir developers who wish to implement LTI 1.3 in their apps. This page assumes that both the tool and platform have been registered with each other. Remember that registering requires a tool and platform to store important details about each other, such as: Example tool details registered with the platform: client_id : &quot;1000000000001&quot; keyset_url : &quot;https://tool.example.edu/.well-known/jwks.json&quot; oidc_login_url : &quot;https://tool.example.edu/login&quot; redirect_uris : &quot;https://tool.example.edu/launch&quot; target_link_ui : &quot;https://tool.example.edu/launch&quot; Example platform details registered with the tool: issuer : &quot;https://platform.example.edu&quot; client_id : &quot;1000000000001&quot; key_set_url : &quot;https://platform.example.edu/.well-known/jwks.json&quot; auth_token_url : &quot;https://platform.example.edu/access_tokens&quot; auth_login_url : &quot;https://platform.example.edu/authorize_redirect&quot; This registration process happens out-of-band before the LTI launch itself can be performed. Typically this information is exchanged between two parties through some external form of communication (e.g. email) or automatic registration and approval process. LTI 1.3 Process Step 1: Third-party Initiated Login https://www.imsglobal.org/spec/security/v1p0/#step-1-third-party-initiated-login An LTI launch begins with a form submission (GET or POST) from a platform webpage. The platform crafts the form using the pre-registered tool configuration and platform details. The form can either target the current window by default or an iframe embedded in the page. For example, this form will target the iframe below it: controller.ex launch_params = %{ # client_id must match the value registered with the tool client_id : &quot;1000000000001&quot; , # issuer value associated with the plaform iss : &quot;https://platform.example.edu&quot; , # tool OIDC login path, the destination this request will be sent to oidc_login_url : &quot;https://tool.example.edu/login&quot; , # the location of the requested LTI resource target_link_uri : &quot;https://tool.example.edu/launch&quot; , # unique token used later by the platform to associate the request with this user session login_hint : &quot;ac5cdc6e-1dd2-97f2-e2c8-0d4236e9b092&quot; , } render ( conn , &quot;lti_launch.html&quot; , launch_params : launch_params ) lti_launch.html.eex &lt;form action=&quot;&lt;%= @launch_params.oidc_login_url %&gt;&quot; method=&quot;post&quot; target=&quot;tool_content&quot; &gt; &lt;input type=&quot;hidden&quot; name=&quot;iss&quot; id=&quot;iss&quot; value=&quot;&lt;%= @launch_params.iss %&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;login_hint&quot; id=&quot;login_hint&quot; value=&quot;&lt;%= @launch_params.login_hint %&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;client_id&quot; id=&quot;client_id&quot; value=&quot;&lt;%= @launch_params.client_id %&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;target_link_uri&quot; id=&quot;target_link_uri&quot; value=&quot;&lt;%= @launch_params.target_link_uri %&gt;&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Launch LTI 1.3 Tool&lt;/button&gt; &lt;/form&gt; &lt;iframe src=&quot;about:blank&quot; name=&quot;tool_content&quot; title=&quot;Tool Content&quot;&gt;&lt;/iframe&gt; When a user clicks the &quot;Launch LTI 1.3 Tool&quot; button the form request will be sent to the tool's OIDC login endpoint and the LTI 1.3 handshake will begin. Step 2: Authentication Request https://www.imsglobal.org/spec/security/v1p0/#step-2-authentication-request When the request is recieved, the tool will validate the issuer and client_id match the registered platform, validate the login_hint param is present and issue a redirect to the platform's OIDC (OpenID Connect) endpoint to authenticate the user. If validation is successful, the tool will craft the OIDC request with the following parameters: %{ # OIDC and LTI 1.3 required params &quot;scope&quot; = &gt; &quot;openid&quot; , &quot;response_type&quot; = &gt; &quot;id_token&quot; , &quot;response_mode&quot; = &gt; &quot;form_post&quot; , &quot;prompt&quot; = &gt; &quot;none&quot; , # client_id that was given by POST params, also associated with the platform registration &quot;client_id&quot; = &gt; &quot;some-client-id&quot; , # the tool url to redirect back to after successful login &quot;redirect_uri&quot; = &gt; &quot;some-redirect_uri&quot; , # unique token associated with this request and used later to prevent CSRF &quot;state&quot; = &gt; &quot;some-unique-token&quot; , # unique identifier cached by the platform to prevent replay attacks &quot;nonce&quot; = &gt; &quot;some-unique-nonce&quot; , # opaque string used by the platform to validate the user session associated with the request &quot;login_hint&quot; = &gt; &quot;some-login-hint&quot; , } For example, the final request using GET to the platform will look something like: GET /authorize_redirect?scope=openid&amp;response_type=id_token&amp;... etc. Step 3: Authentication Response https://www.imsglobal.org/spec/security/v1p0/#step-3-authentication-response The platform will recieve the authorize_redirect request from the tool and it will validate the required OIDC params are present, validate the login_hint is associated with the current user session, validate the client_id is associated with a registered tool, validate the redirect_url matches one of the registered urls, and finally validate the nonce has not been used before. If valid, the platform will issue one final POST request to the tool's specified redirect_uri with the recieved state token and an id_token JWT containing the LTI 1.3 claims such as user details, context info, and any other LTI specific or custom claims that may be supported by the platform. Here is an example of the LTI params within the id_token JWT. Full example resource link request . %{ # security claims &quot;iss&quot; = &gt; &quot;https://platform.example.edu&quot; , &quot;sub&quot; = &gt; &quot;a6d5c443-1f51-4783-ba1a-7686ffe3b54a&quot; , &quot;aud&quot; = &gt; [ &quot;962fa4d8-bcbf-49a0-94b2-2de05ad274af&quot; ] , &quot;exp&quot; = &gt; 1510185728 , &quot;iat&quot; = &gt; 1510185228 , &quot;azp&quot; = &gt; &quot;962fa4d8-bcbf-49a0-94b2-2de05ad274af&quot; , &quot;nonce&quot; = &gt; &quot;fc5fdc6d-5dd6-47f4-b2c9-5d1216e9b771&quot; , # user details claims &quot;name&quot; = &gt; &quot;Ms Jane Marie Doe&quot; , &quot;given_name&quot; = &gt; &quot;Jane&quot; , &quot;family_name&quot; = &gt; &quot;Doe&quot; , &quot;middle_name&quot; = &gt; &quot;Marie&quot; , &quot;picture&quot; = &gt; &quot;https://platform.example.edu/jane.jpg&quot; , &quot;email&quot; = &gt; &quot;jane@platform.example.edu&quot; , &quot;locale&quot; = &gt; &quot;en-US&quot; , # LTI claims &quot;https://purl.imsglobal.org/spec/lti/claim/deployment_id&quot; : &quot;07940580-b309-415e-a37c-914d387c1150&quot; , &quot;https://purl.imsglobal.org/spec/lti/claim/message_type&quot; = &gt; &quot;LtiResourceLinkRequest&quot; , &quot;https://purl.imsglobal.org/spec/lti/claim/version&quot; = &gt; &quot;1.3.0&quot; , &quot;https://purl.imsglobal.org/spec/lti/claim/roles&quot; = &gt; [ &quot;http://purl.imsglobal.org/vocab/lis/v2/institution/person#Student&quot; , &quot;http://purl.imsglobal.org/vocab/lis/v2/membership#Learner&quot; , &quot;http://purl.imsglobal.org/vocab/lis/v2/membership#Mentor&quot; ] , &quot;https://purl.imsglobal.org/spec/lti/claim/role_scope_mentor&quot; = &gt; [ &quot;fad5fb29-a91c-770-3c110-1e687120efd9&quot; , &quot;5d7373de-c76c-e2b-01214-69e487e2bd33&quot; , &quot;d779cfd4-bc7b-019-9bf1a-04bf1915d4d0&quot; ] , &quot;https://purl.imsglobal.org/spec/lti/claim/context&quot; = &gt; { &quot;id&quot; = &gt; &quot;c1d887f0-a1a3-4bca-ae25-c375edcc131a&quot; , &quot;label&quot; = &gt; &quot;ECON 1010&quot; , &quot;title&quot; = &gt; &quot;Economics as a Social Science&quot; , &quot;type&quot; = &gt; [ &quot;http://purl.imsglobal.org/vocab/lis/v2/course#CourseOffering&quot; ] } , &quot;https://purl.imsglobal.org/spec/lti/claim/resource_link&quot; = &gt; { &quot;id&quot; = &gt; &quot;200d101f-2c14-434a-a0f3-57c2a42369fd&quot; , &quot;description&quot; = &gt; &quot;Assignment to introduce who you are&quot; , &quot;title&quot; = &gt; &quot;Introduction Assignment&quot; } , &quot;https://purl.imsglobal.org/spec/lti/claim/tool_platform&quot; = &gt; { &quot;guid&quot; = &gt; &quot;ex/48bbb541-ce55-456e-8b7d-ebc59a38d435&quot; , &quot;contact_email&quot; = &gt; &quot;support@platform.example.edu&quot; , &quot;description&quot; = &gt; &quot;An Example Tool Platform&quot; , &quot;name&quot; = &gt; &quot;Example Tool Platform&quot; , &quot;url&quot; = &gt; &quot;https://platform.example.edu&quot; , &quot;product_family_code&quot; = &gt; &quot;ExamplePlatformVendor-Product&quot; , &quot;version&quot; = &gt; &quot;1.0&quot; } , &quot;https://purl.imsglobal.org/spec/lti/claim/target_link_uri&quot; : &quot;https://tool.example.com/lti/48320/ruix8782rs&quot; , &quot;https://purl.imsglobal.org/spec/lti/claim/launch_presentation&quot; = &gt; { &quot;document_target&quot; = &gt; &quot;iframe&quot; , &quot;height&quot; = &gt; 320 , &quot;width&quot; = &gt; 240 , &quot;return_url&quot; = &gt; &quot;https://platform.example.edu/terms/201601/courses/7/sections/1/resources/2&quot; } , &quot;https://purl.imsglobal.org/spec/lti/claim/lis&quot; = &gt; { &quot;person_sourcedid&quot; = &gt; &quot;example.edu:71ee7e42-f6d2-414a-80db-b69ac2defd4&quot; , &quot;course_offering_sourcedid&quot; = &gt; &quot;example.edu:SI182-F16&quot; , &quot;course_section_sourcedid&quot; = &gt; &quot;example.edu:SI182-001-F16&quot; } , # additional custom claims &quot;https://purl.imsglobal.org/spec/lti/claim/custom&quot; = &gt; { &quot;xstart&quot; = &gt; &quot;2017-04-21T01:00:00Z&quot; , &quot;request_url&quot; = &gt; &quot;https://tool.com/link/123&quot; } , # additional extensions claims &quot;http://www.ExamplePlatformVendor.com/session&quot; = &gt; { &quot;id&quot; = &gt; &quot;89023sj890dju080&quot; } } These params are encoded and signed as a JWT using RSA256 and the platform's private JWK, which can later be verfied by the tool using the platforms publicly accessible JWK. This redirect POST can be accomplished by rendering an html form and (if enabled) using javascript to submit on the user's behalf. &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;You are being redirected...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;You are being redirected...&lt;/div&gt; &lt;form name=&quot;post_redirect&quot; action=&quot;&lt;%= @redirect_uri %&gt;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;state&quot; value=&quot;&lt;%= @state %&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id_token&quot; value=&quot;&lt;%= @id_token %&gt;&quot; /&gt; &lt;noscript&gt; &lt;input type=&quot;submit&quot; value=&quot;Click here to continue&quot; /&gt; &lt;/noscript&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () { document.getElementsByName(&quot;post_redirect&quot;)[0].style.display = &quot;none&quot;; document.forms[&quot;post_redirect&quot;].submit(); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Step 4: Resource is displayed https://www.imsglobal.org/spec/security/v1p0/#step-4-resource-is-displayed Finally, if all validations have passed and the launch was successful, the LTI 1.3 resource will be displayed in the user's browser. References and Useful Links Learning Tools Interoperability Core Specification - http://www.imsglobal.org/spec/lti/v1p3/ IMS Security Framework - https://www.imsglobal.org/spec/security/v1p0 Canvas Platform Implementaion (authentication_controller.rb) - https://github.com/instructure/canvas-lms/blob/master/app/controllers/lti/ims/authentication_controller.rb IMS PHP Tool Library https://github.com/IMSGlobal/lti-1-3-php-library","ref":"implementing.html#lti-1-3-launch-overview","title":"LTI 1.3 - LTI 1.3 Launch Overview","type":"extras"},{"doc":"Torus supports LTI 1.3 integration and leverages the Learning Management System (LMS) for course delivery. The philosophy of Torus is to focus and excel at what it is specifically designed for, which is rich course content authoring, delivery and data-driven continuous improvement. Many of the necessary features of course delivery such as roster management, grade book management and scheduling are deferred to the LMS, which is what it is specifically designed for. These aspects of the student and instructor experience are crucial and require tight integration which is enabled by the LTI 1.3 standard. Many LMSs currently support the LTI 1.3 standard including Canvas, Blackboard, Moodle, Brightspace D2L, and more. Each LMS may have a slightly different method of configuring an external tool like Torus, but in general the process is similar between them and is driven by the LTI 1.3 Specification .","ref":"config.html","title":"LTI 1.3 Configuration","type":"extras"},{"doc":"Institutions Torus has the concept of an Institution which represents an organization whom wishes to use Torus, typically from their own self-hosted LMS or a cloud-hosted one. For example, Carnegie Mellon University would be considered an institution, and so is The Open Learning Initiative (OLI). Registrations A Registration represents a configured LTI connection from an institution in Torus. Typically an institution will have a single registration but there may be certain cases where an institution has multiple registrations could be an institution that has multiple LMSs. Each one of these LMSs may belong to the same Institution but will have separate registrations. The combination of issuer (typically a URL e.g. https://canvas.oli.cmu.edu ) and client_id represents a globally unique registration. The issuer represents the LTI Platform, not necessarily the institution. For example, https://canvas.instructure.com is the issuer that represents any institution who may be using Instructure's cloud platform and the client id represents the specific registration, and therefore institution. Deployments A Deployment can be thought of as the next tier below registrations. A registration may have many deployments. For example, a Registration may have one deployment for every course, or a single deployment shared globally across the entire LMS. There is some flexibility to how these concepts could be represented for an organization, but typically an organization will have a single Institution , with a single Registration for their LMS, and they may have one or many Deployments within their LMS depending on if the tool is configure globally or for an individual department/course. Institutions, registrations and deployments are currently created and managed by a Torus administrator. In the future, we plan to add more flexibility on how these entities can be registered and approved. For now, please contact OLI if you wish to deliver a Torus course from your organization's LMS. If you are running your own instance of Torus, the steps below outline the process for creating these entities required for LTI 1.3 integration with an LMS.","ref":"config.html#concepts","title":"LTI 1.3 Configuration - Concepts","type":"extras"},{"doc":"To get connected with Torus, you must first configure your LMS LTI 1.3 connection. This process will vary depending on your institution's LMS, but the basic principles are the same. Refer to the specific instructions for your LMS in the Configuring LTI 1.3 in LMS section below. You will only have to perform this setup process once for your LMS. After your LMS has been configured, you should be able to access Torus from your LMS. The first time you launch into Torus from your LMS, you will be presented with a &quot;Register Your Institution&quot; form. Please fill out this form and allow OLI up to 2 business days to review and approve your request. If your are running your own instance of Torus, your Torus admin will need to approve this request under Institutions &gt; Pending Requests. Once your request has been approved, you should now be able to access Torus from your LMS which will guide you through course setup.","ref":"config.html#connecting-to-torus-with-lti-1-3","title":"LTI 1.3 Configuration - Connecting to Torus with LTI 1.3","type":"extras"},{"doc":"Canvas Create LTI 1.3 Developer Key Canvas Docs: https://community.canvaslms.com/t5/Admin-Guide/How-do-I-configure-an-LTI-key-for-an-account/ta-p/140 Canvas requires elevated privileges to configure LTI 1.3 Developer Keys and Apps. Canvas administrators should have the necessary privileges. If you don't see the options mentioned below, you may not have proper privileges or your canvas instance may be an older version which does not support LTI 1.3. In either case, you should check with your LMS administrator. In Canvas using the left main menu, select Admin &gt; [Admin Account Name]. &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/admin_all_accounts.png&quot; width=&quot;400px&quot; /&gt; Then click &quot;Developer Keys&quot; link &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/developer_keys_link.png&quot; width=&quot;200px&quot; /&gt; Under Developer Keys, click &quot;+ Developer Key&quot; &gt; &quot;+ LTI Key&quot; You have two options when configuring an LTI 1.3 Developer Key in Canvas: OPTION 1 (Recommended) - Automatic Configuration using JSON URL Select Enter URL for the method Configure the following fields with values that correspond to your torus deployment. For example, if you are hosting torus at a specific domain or in a development environment using a service such as ngrok, you will want to replace all instances of proton.oli.cmu.edu with your domain or ngrok address e.g. ba7c432acd17.ngrok.io . Redirect URIs: https://proton.oli.cmu.edu/lti/launch Developer Key JSON URL: https://proton.oli.cmu.edu/lti/developer_key.json Click &quot;Save&quot; OPTION 2 - Manual Entry Configure the following fields with values that correspond to your torus deployment. For example, if you are hosting torus at a specific domain or in a development environment using a service such as ngrok, you will want to replace all instances of proton.oli.cmu.edu with your domain or ngrok address e.g. ba7c432acd17.ngrok.io . Key Name: OLI Torus Owner Email: admin@proton.oli.cmu.edu Redirect URIs: https://proton.oli.cmu.edu/lti/launch Title: Torus Description: Create, deliver and iteratively improve course content with Torus, through the Open Learning Initiative Target Link URI: https://proton.oli.cmu.edu/lti/launch OpenID Connect Initiation Url: https://proton.oli.cmu.edu/lti/login JWK Method: Public JWK URL Public JWK URL: https://proton.oli.cmu.edu/.well-known/jwks.json Placements: Configure depending on your needs, or leave defaults Click &quot;Save&quot;. Enable the newly created LTI Key by setting it to &quot;ON&quot;. Your LTI 1.3 key is now configured and ready to use! Copy the corresponding number under details for future use, (e.g. 10000000000034). This will be our Client ID . Add Torus as an External Tool link in your Canvas course Canvas Docs: https://community.canvaslms.com/t5/Admin-Guide/How-do-I-configure-an-external-app-for-an-account-using-a-client/ta-p/202 Navigate to your course and click &quot;Settings&quot; &gt; &quot;Apps&quot; &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/settings_link.png&quot; width=&quot;200px&quot; /&gt; &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/settings_add_app.png&quot; width=&quot;800px&quot; /&gt; Select Configuration Type &quot;By Client ID&quot; and insert the Client ID we kept from the previous steps. Click &quot;Submit&quot;. When prompted to install the tool, select &quot;Install&quot;. &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/add_app.png&quot; width=&quot;800px&quot; /&gt; We must configure this specific deployment with torus, as mentioned in the previous section 'Configuring LTI 1.3 in Torus'. To do this, we must get the Deployment ID by Selecting the &quot;gear&quot; menu &gt; Deployment Id. &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/deployment_gear_icon.png&quot; width=&quot;200px&quot; /&gt; &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/deployment_id.png&quot; width=&quot;500px&quot; /&gt; Copy this entire ID and use it to configure a deployment in Torus as outlined in the previous section 'Configuring LTI 1.3 in Torus'. If you configured your LTI 1.3 Developer Key with placements other than Link, you will see Torus appear in those places. Otherwise, the default placement is a Link Selection placement which allows you to add Torus to any module in your course as you normally would by clicking the plus &quot;+&quot; button on a module, selecting &quot;External Tool&quot; and finally selecting the Torus tool we just added. Click &quot;Add Item&quot;. &lt;img src=&quot; https://raw.githubusercontent.com/Simon-Initiative/oli-torus/master/docs/images/add_external_tool.png&quot; width=&quot;800px&quot; /&gt; Navigate to Torus through the placement you configured, and you should be guided through course setup, which is outside the scope of this document. If you see any errors related to your LTI configuration, you may need to revisit the previous section 'Configuring LTI 1.3 in Torus' or your canvas instance may be improperly configured. The error message should give you an indication of the specific issue and provide a link to OLI support for further help if needed. Blackboard Coming soon... Moodle Coming soon...","ref":"config.html#configuring-lti-1-3-in-lms","title":"LTI 1.3 Configuration - Configuring LTI 1.3 in LMS","type":"extras"},{"doc":"To manually configure an LTI 1.3 integration in Torus, we need to gather some important LMS details first. These details can usually be supplied by an LMS administrator. For certain values such as Client ID and Deployment ID, you will need to configure Torus in your LMS first before you can get this value. It is recommended you or your LMS administrator follow the steps in the section 'Configuring LTI 1.3 in LMS' below to obtain this. Issuer (e.g. https://canvas.oli.cmu.edu ) Client ID: This is obtained by creating an LTI 1.3 Developer Key in the LMS. See specific instructions below depending on your LMS. Key Set Url (e.g. https://canvas.oli.cmu.edu/api/lti/security/jwks ) Auth Token Url (e.g. https://canvas.oli.cmu.edu/login/oauth2/token ) Auth Login Url (e.g. https://canvas.oli.cmu.edu/api/lti/authorize_redirect ) Auth Server Url (e.g. https://canvas.oli.cmu.edu ) KID (e.g. 2018-05-18T22:33:20Z). This can also be obtained by entering the Key Set URL in your browser and extracting the first value for &quot;kid&quot;:&quot;2018-05-18T22:33:20Z&quot; Deployment ID This is obtained by creating an LTI 1.3 Deployment in the LMS. See specific instructions below depending on your LMS. In Torus as an Administrator, select &quot;Institutions&quot; from the sidebar on the left of the workspace, then click &quot;Register New Institution&quot; Enter your Institution's details and click &quot;Save&quot; Click the &quot;Details&quot; button for the institution you just created Click &quot;Add Registration&quot; and enter registration details, which are outlined above and should be provided by your LMS administrator. You may use a placeholder value for Client ID if you haven't configured an LTI Key in your LMS yet, but it is very important you return and update this value before launching into Torus. When finished, click on the registration labeled by its [Issuer - Client ID] to expand it. Click &quot;Add Deployment&quot; and enter the Deployment ID saved from the instructions below when you created a deployment in your LMS. Click &quot;Save&quot;. Once you have a Registration and a Deployment configured for your Institution , you can now return to your LMS and launch into Torus and you will be guided through course setup, which is outside the scope of this document.","ref":"config.html#manual-lti-1-3-configuration-in-torus-torus-admin","title":"LTI 1.3 Configuration - Manual LTI 1.3 Configuration in Torus (Torus Admin)","type":"extras"},{"doc":"Torus supports importing, or ingesting, externally developed course material.","ref":"overview.html","title":"Course material ingestion","type":"extras"},{"doc":"The Torus ingestion feature takes as input a course digest archive and converts that into a course project. Course digest archives can be produced from a variety of different sources, either manually or via automated tools. There is an automated tool that produces course digest archives from the legacy OLI XML course format. https://github.com/Simon-Initiative/course-digest [[assets/ingest.png]]","ref":"overview.html#overview","title":"Course material ingestion - Overview","type":"extras"},{"doc":"Course digest archives are zip files that contain JSON files corresponding to curriculum resources. In a course digest, the following are the minimally required files: _project.json This file describes high level course meta data. { &quot;slug&quot;: &quot;edx_bio_1&quot;, &quot;title&quot;: &quot;Introduction to Biology&quot;, &quot;description&quot;: &quot;An introductory biology course suitable for non-majors&quot;, &quot;type&quot;: &quot;Manifest&quot; } _hierarchy_.json This file describes the course outline, or hierarchy, defining the units and modules of a course and the pages that they contain. The following is an excerpt of a sample hierarchy file: { &quot;type&quot;: &quot;Hierarchy&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;container&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;container&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;item&quot;, &quot;children&quot;: [], &quot;idref&quot;: &quot;u-introduction-m-introduction-p-welcome&quot; } ], &quot;id&quot;: &quot;u-introduction-m-introduction&quot;, &quot;title&quot;: &quot;Introduction&quot; }, { &quot;type&quot;: &quot;container&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;item&quot;, The hierarchy file is essential a nested collection of children, that are of either type &quot;container&quot; (to represent a unit or module) or of type &quot;item&quot; (to represent a page reference). For &quot;item&quot; instances, the idref attribute is a reference to the id attribute of resource JSON file. _media-manifest_.json This file is a listing of all media assets that this course has prestaged into Torus S3 storage. { &quot;mediaItems&quot;: [ { &quot;name&quot;: &quot;1x1.png&quot;, &quot;url&quot;: &quot;https://torus-media-dev.s3.amazonaws.com/media/nothingatall/1x1.png&quot;, &quot;fileSize&quot;: 95, &quot;mimeType&quot;: &quot;image/png&quot;, &quot;md5&quot;: &quot;71a50dbba44c78128b221b7df7bb51f1&quot; }, { &quot;name&quot;: &quot;code-variable.png&quot;, &quot;url&quot;: &quot;https://torus-media-dev.s3.amazonaws.com/media/nothingatall/code-variable.png&quot;, &quot;fileSize&quot;: 3671, &quot;mimeType&quot;: &quot;image/png&quot;, &quot;md5&quot;: &quot;0c084906e4502a6e93739b20a4ac119f&quot; }, Resource Files Beyond the three require metadata files, a course digest archive also contains any number of resource specific JSON files. These files must be named &lt;id&gt;.json where the id is the string identifier used to reference the resource from idref attributes in the course hierarchy file. Currently three types of resource files are supported for ingestion: Page, Activity, and Objective. All three follow the same format of requiring type , id , title , content and objectives attributes to be defined. Samples of each follow: Learning Objective { &quot;type&quot;: &quot;Objective&quot;, &quot;id&quot;: &quot;u-hardware_and_software-m-hardware_and_software-p-kilobytes_megabytes_and_gigabytes_LO_1&quot;, &quot;title&quot;: &quot;Solve word problems with arithmetic combinations of kilobytes, megabytes, and gigabytes.&quot;, &quot;content&quot;: {}, &quot;objectives&quot;: [] } Activity { &quot;type&quot;: &quot;Activity&quot;, &quot;id&quot;: &quot;3550878268&quot;, &quot;title&quot;: &quot;Image coding activity&quot;, &quot;tags&quot;: [], &quot;content&quot;: { &quot;authoring&quot;: { &quot;parts&quot;: [ { &quot;id&quot;: &quot;1&quot;, &quot;responses&quot;: [ { &quot;id&quot;: &quot;3713976972&quot;, &quot;score&quot;: 1, &quot;rule&quot;: &quot;input like {1}&quot;, &quot;feedback&quot;: { &quot;id&quot;: &quot;2848932877&quot;, &quot;content&quot;: { &quot;id&quot;: &quot;2564146359&quot;, &quot;model&quot;: [ { &quot;type&quot;: &quot;p&quot;, &quot;children&quot;: [ { &quot;text&quot;: &quot;Correct&quot; } ] } ] Page { &quot;type&quot;: &quot;Page&quot;, &quot;id&quot;: &quot;u-security-m-contents_security-p-contents_security&quot;, &quot;originalFile&quot;: &quot;&quot;, &quot;title&quot;: &quot;Contents: Security&quot;, &quot;tags&quot;: [], &quot;unresolvedReferences&quot;: [], &quot;content&quot;: { &quot;model&quot;: [ { &quot;type&quot;: &quot;content&quot;, &quot;purpose&quot;: &quot;none&quot;, &quot;id&quot;: &quot;3177050314&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;ul&quot;, &quot;children&quot;: [ { &quot;type&quot;: &quot;li&quot;, &quot;children&quot;: [ { &quot;text&quot;: &quot; &quot; }, {","ref":"overview.html#course-digest-format","title":"Course material ingestion - Course Digest Format","type":"extras"},{"doc":"Torus pages and activities can contain multimedia content such as images, audio, and video. Currently, video support in Torus is via YouTube. Audio support is via the HTML5 &lt;audio&gt; element, and images are supported via HTML &lt;img&gt; element.","ref":"media.html","title":"Media assets","type":"extras"},{"doc":"For images and audio sources, Torus supports the use of both &quot;internally&quot; hosted media assets and &quot;externally&quot; hosted media assets. This simply means that an author of a course, when inserting an image into a page can choose to either upload an image file to Torus to use (thus, &quot;interally hosted&quot;) or to copy and paste a URL of a publicly available image to use (thus, &quot;externally hosted&quot;). For internally hosted assets, Torus does several things with that media asset to both ensure correct and efficient delivery of a course project and to enable a richer authoring experience: Deduplication: Upload receiving the uplaod of an asset, Torus calculates an MD5 hash and compares it all other assets of that course to prevent duplicate images from being added into the system. Cached, immutable storage: Once the asset is guaranteed to be unique, Torus stores it in AWS S3 storage, where it can be directly accessible via a URL. At this point, the asset is immutable: it cannot be updated or deleted by a Torus end user. This is necessary to allow proper functioning of the Torus publication model. See the Immutability section below for a use case that demonstrates this importance. The S3 buckets are fronted by an AWS edge caching solution. Project assocation: Meta-data regarding the asset is associated with the course project, primarily to power the &quot;Media Library&quot; feature within Torus. An author can then browse their media library within Torus to select the asset for use in other places within their course project. For externally hosted asset references, Torus does none of the above. It simply allows that external URL to be embedded in the content of the page and the activity.","ref":"media.html#external-vs-internal-media-asset-storage","title":"Media assets - External vs Internal Media Asset Storage","type":"extras"},{"doc":"Immutability of media assets is paramount to correct delivery of a course project as that course project evolves over time. The lack of an immutability guarantee for externally hosted assets can cause &quot;change leakage&quot; problems. Consider the following scenario: An author embeds a reference to an externally hosted image in a page in their course. Perhaps the author has a blog where they have images and other assets present. Course sections are created and students begin to access the course material. The author then decides to begin editing their course material to prepare for a major revision that they will publish in a few months for the next semester of course sections. The author deems it necessary to update several of the images hosted on their blog to support these course material updates. While the Torus course material updates will not be visible to students (since the author hasn't &quot;Published&quot; those changes yet), as soon as the author changes those images, students working through the active course section see the new, updated images.","ref":"media.html#immutability","title":"Media assets - Immutability","type":"extras"},{"doc":"Developers creating course digests to ingest into Torus can choose to take advantage of Torus &quot;internally hosted&quot; assets and the media library feature. Asset URL references within pages and activities must use the Torus AWS URL prefixes, so that at runtime these reference resolve to the correct Torus asset location. The format of the URL is https://d2xvti2irp4c7t.cloudfront.net/media/${project_slug}/${file_name} , where project_slug is a unique project identifier (not necessarily the actual project slug that will get generated, more so simply a folder name) and file_name of course is the name of the file corresponding to the asset. Every asset in a course project that is intended to be tracked by Torus in the media library must have an entry in the _media_manifest.json file of the course digest. Before or after a course digest has been ingested, the actual media assets themselves need to be &quot;staged&quot; in the Torus AWS S3 instance. Once both the digest has been ingested and the assets staged, an author can begin accessing and editing the newly ingested course and be able to view the existing assets in pages. Furthermore, the author is able to browse the library of all asssets via the Media Library capability.","ref":"media.html#asset-considerations-for-course-ingestion","title":"Media assets - Asset Considerations for Course Ingestion","type":"extras"},{"doc":"The OLI Legacy course digest tool ( https://github.com/Simon-Initiative/course-digest ) contains an asset staging implementation that developers of other digests can reuse. This implemenation takes as input a media manifest file and expects all the assets referenced within it to also be present in the local filesystem. The implementation simply uploads, serially, the files in the manifest into the Torus AWS S3 storage. External developers that want to stage assets must work with internal Torus engineering to first obtain the project_slug identifier to use in constructing asset URLs, and the S3 credentials to use to drive the upload implementation.","ref":"media.html#asset-staging","title":"Media assets - Asset Staging","type":"extras"}]